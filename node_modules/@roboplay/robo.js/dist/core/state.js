import { FLASHCORE_KEYS } from './constants.js';
import { logger } from './logger.js';
import { Flashcore } from './flashcore.js';

const i={};class o{static _prefixes=new Set;_prefix;_options;constructor(e,s){this._prefix=e,this._options=s,this.fork=this.fork.bind(this),this.getState=this.getState.bind(this),this.setState=this.setState.bind(this);}static fork(e,s){return o._prefixes.add(e),new o(e,s)}static listForks(){return new Array(...o._prefixes)}fork(e,s){return new o(`${this._prefix}__${e}`,s)}getState(e){return d(`${this._prefix}__${e}`)}setState(e,s,n){S(`${this._prefix}__${e}`,s,{...n??{},persist:n?.persist??this._options?.persist});}}const g=["String","Number","Boolean","Array","Object"];function u(t,e={value:!1}){if(typeof t!="function"){if(t!==null&&typeof t=="object")if(g.includes(t.constructor.name)){if(Array.isArray(t))return t.map(s=>u(s,e)).filter(s=>s!==void 0);{const s={};for(const n in t){const r=u(t[n],e);r!==void 0&&(s[n]=r);}return s}}else {e.value||(logger.warn("Removed state value as it is not serializable:",t),e.value=!0);return}return t}}function x(){Object.keys(i).forEach(t=>{delete i[t];});}function d(t){return i[t]}function k(t){return t?new Promise((e,s)=>{const n=r=>{l(r)&&(t.off("message",n),e(r.state));};t.on("message",n),t.once("error",r=>{t.off("message",n),s(r);}),t.send({type:"state-save"});}):Promise.resolve({})}function l(t){return t.type==="state-load"||t.type==="state-save"}function _(t){logger.debug("Loading state...",t),Object.keys(t).forEach(e=>{i[e]=t[e];});}function b(){logger.debug("Saving state...",i),process.send({type:"state-save",state:i});}function S(t,e,s){const{persist:n}=s??{};i[t]=e,n&&(async()=>{const p=await Flashcore.get(FLASHCORE_KEYS.state)??{};p[t]=e,Flashcore.set(FLASHCORE_KEYS.state,p);})();}

export { o as State, x as clearState, d as getState, k as getStateSave, _ as loadState, u as removeInstances, b as saveState, S as setState, i as state };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=state.js.map