{"version":3,"sources":["../../src/core/radix3.ts"],"names":["NODE_TYPES","createRouter","options","ctx","createRadixNode","normalizeTrailingSlash","p","path","insert","lookup","data","remove","staticPathNode","sections","params","paramsFound","wildcardNode","node","wildCardParam","i","section","nextNode","isStaticRoute","_unnamedPlaceholderCtr","childNode","type","getNodeType","success","lastSection","parentNode","str"],"mappings":"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","sourcesContent":["/**\n * This was forked from radix3 (MIT License)\n * https://github.com/unjs/radix3\n *\n * It was done to minimize size and remove unnecessary features.\n */\nexport const NODE_TYPES = {\n\tNORMAL: 0 as const,\n\tWILDCARD: 1 as const,\n\tPLACEHOLDER: 2 as const\n}\n\ntype _NODE_TYPES = typeof NODE_TYPES\nexport type NODE_TYPE = _NODE_TYPES[keyof _NODE_TYPES]\n\ntype _RadixNodeDataObject = { params?: never; [key: string]: unknown }\nexport type RadixNodeData<T extends _RadixNodeDataObject = _RadixNodeDataObject> = T\nexport type MatchedRoute<T extends RadixNodeData = RadixNodeData> = Omit<T, 'params'> & {\n\tparams?: Record<string, unknown>\n}\n\nexport interface RadixNode<T extends RadixNodeData = RadixNodeData> {\n\ttype: NODE_TYPE\n\tparent: RadixNode<T> | null\n\tchildren: Map<string, RadixNode<T>>\n\tdata: RadixNodeData | null\n\tparamName: string | null\n\twildcardChildNode: RadixNode<T> | null\n\tplaceholderChildNode: RadixNode<T> | null\n}\n\nexport interface RadixRouterOptions {\n\tstrictTrailingSlash?: boolean\n\troutes?: Record<string, _RadixNodeDataObject>\n}\n\nexport interface RadixRouterContext<T extends RadixNodeData = RadixNodeData> {\n\toptions: RadixRouterOptions\n\trootNode: RadixNode<T>\n\tstaticRoutesMap: Record<string, RadixNode>\n}\n\nexport interface RadixRouter<T extends RadixNodeData = RadixNodeData> {\n\tctx: RadixRouterContext<T>\n\n\t/**\n\t * Perform lookup of given path in radix tree\n\t * @param path - the path to search for\n\t *\n\t * @returns The data that was originally inserted into the tree\n\t */\n\tlookup(path: string): MatchedRoute<T> | null\n\n\t/**\n\t * Perform an insert into the radix tree\n\t * @param path - the prefix to match\n\t * @param data - the associated data to path\n\t *\n\t */\n\tinsert(path: string, data: T | unknown): void\n\n\t/**\n\t * Perform a remove on the tree\n\t * @param { string } data.path - the route to match\n\t *\n\t * @returns A boolean signifying if the remove was successful or not\n\t */\n\tremove(path: string): boolean\n}\n\nexport function createRouter<T extends RadixNodeData = RadixNodeData>(\n\toptions: RadixRouterOptions = {}\n): RadixRouter<T> {\n\tconst ctx: RadixRouterContext = {\n\t\toptions,\n\t\trootNode: createRadixNode(),\n\t\tstaticRoutesMap: {}\n\t}\n\n\tconst normalizeTrailingSlash = (p: string) => (options.strictTrailingSlash ? p : p.replace(/\\/$/, '') || '/')\n\n\tif (options.routes) {\n\t\tfor (const path in options.routes) {\n\t\t\tinsert(ctx, normalizeTrailingSlash(path), options.routes[path])\n\t\t}\n\t}\n\n\treturn {\n\t\tctx,\n\t\t// @ts-expect-error - this is fine\n\t\tlookup: (path: string) => lookup(ctx, normalizeTrailingSlash(path)),\n\t\tinsert: (path: string, data: unknown) => insert(ctx, normalizeTrailingSlash(path), data),\n\t\tremove: (path: string) => remove(ctx, normalizeTrailingSlash(path))\n\t}\n}\n\nfunction lookup(ctx: RadixRouterContext, path: string): MatchedRoute {\n\tconst staticPathNode = ctx.staticRoutesMap[path]\n\tif (staticPathNode) {\n\t\treturn staticPathNode.data\n\t}\n\n\tconst sections = path.split('/')\n\n\tconst params: MatchedRoute['params'] = {}\n\tlet paramsFound = false\n\tlet wildcardNode = null\n\tlet node = ctx.rootNode\n\tlet wildCardParam = null\n\n\tfor (let i = 0; i < sections.length; i++) {\n\t\tconst section = sections[i]\n\n\t\tif (node.wildcardChildNode !== null) {\n\t\t\twildcardNode = node.wildcardChildNode\n\t\t\twildCardParam = sections.slice(i).join('/')\n\t\t}\n\n\t\t// Exact matches take precedence over placeholders\n\t\tconst nextNode = node.children.get(section)\n\t\tif (nextNode !== undefined) {\n\t\t\tnode = nextNode\n\t\t} else {\n\t\t\tnode = node.placeholderChildNode\n\t\t\tif (node !== null) {\n\t\t\t\tparams[node.paramName] = section\n\t\t\t\tparamsFound = true\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((node === null || node.data === null) && wildcardNode !== null) {\n\t\tnode = wildcardNode\n\t\tparams[node.paramName || '_'] = wildCardParam\n\t\tparamsFound = true\n\t}\n\n\tif (!node) {\n\t\treturn null\n\t}\n\n\tif (paramsFound) {\n\t\treturn {\n\t\t\t...node.data,\n\t\t\tparams: paramsFound ? params : undefined\n\t\t}\n\t}\n\n\treturn node.data\n}\n\nfunction insert(ctx: RadixRouterContext, path: string, data: unknown) {\n\tlet isStaticRoute = true\n\n\tconst sections = path.split('/')\n\n\tlet node = ctx.rootNode\n\n\tlet _unnamedPlaceholderCtr = 0\n\n\tfor (const section of sections) {\n\t\tlet childNode: RadixNode<RadixNodeData>\n\n\t\tif ((childNode = node.children.get(section))) {\n\t\t\tnode = childNode\n\t\t} else {\n\t\t\tconst type = getNodeType(section)\n\n\t\t\t// Create new node to represent the next part of the path\n\t\t\tchildNode = createRadixNode({ type, parent: node })\n\n\t\t\tnode.children.set(section, childNode)\n\n\t\t\tif (type === NODE_TYPES.PLACEHOLDER) {\n\t\t\t\tchildNode.paramName = section === '*' ? `_${_unnamedPlaceholderCtr++}` : section.slice(1)\n\t\t\t\tnode.placeholderChildNode = childNode\n\t\t\t\tisStaticRoute = false\n\t\t\t} else if (type === NODE_TYPES.WILDCARD) {\n\t\t\t\tnode.wildcardChildNode = childNode\n\t\t\t\tchildNode.paramName = section.slice(3 /* \"**:\" */) || '_'\n\t\t\t\tisStaticRoute = false\n\t\t\t}\n\n\t\t\tnode = childNode\n\t\t}\n\t}\n\n\t// Store whatever data was provided into the node\n\tnode.data = data as _RadixNodeDataObject\n\n\t// Optimization, if a route is static and does not have any\n\t// variable sections, we can store it into a map for faster retrievals\n\tif (isStaticRoute === true) {\n\t\tctx.staticRoutesMap[path] = node\n\t}\n\n\treturn node\n}\n\nfunction remove(ctx: RadixRouterContext, path: string) {\n\tlet success = false\n\tconst sections = path.split('/')\n\tlet node = ctx.rootNode\n\n\tfor (const section of sections) {\n\t\tnode = node.children.get(section)\n\t\tif (!node) {\n\t\t\treturn success\n\t\t}\n\t}\n\n\tif (node.data) {\n\t\tconst lastSection = sections[sections.length - 1]\n\t\tnode.data = null\n\t\tif (Object.keys(node.children).length === 0) {\n\t\t\tconst parentNode = node.parent\n\t\t\tparentNode.children.delete(lastSection)\n\t\t\tparentNode.wildcardChildNode = null\n\t\t\tparentNode.placeholderChildNode = null\n\t\t}\n\t\tsuccess = true\n\t}\n\n\treturn success\n}\n\nfunction createRadixNode(options: Partial<RadixNode> = {}): RadixNode {\n\treturn {\n\t\ttype: options.type || NODE_TYPES.NORMAL,\n\t\tparent: options.parent || null,\n\t\tchildren: new Map(),\n\t\tdata: options.data || null,\n\t\tparamName: options.paramName || null,\n\t\twildcardChildNode: null,\n\t\tplaceholderChildNode: null\n\t}\n}\n\nfunction getNodeType(str: string) {\n\tif (str.startsWith('**')) {\n\t\treturn NODE_TYPES.WILDCARD\n\t}\n\tif (str[0] === ':' || str === '*') {\n\t\treturn NODE_TYPES.PLACEHOLDER\n\t}\n\treturn NODE_TYPES.NORMAL\n}\n"]}