{"version":3,"sources":["../../src/core/router.ts"],"names":["logger","createRouter","Router","route","path","hasQuery","parseQuery","routeIndex","query","queries","queryPair","queryPairSplit","key","result","isArray","i"],"mappings":"AAAA,OAAS,UAAAA,MAAc,cACvB,OAAS,gBAAAC,MAAoB,cAetB,MAAMC,CAAO,CACF,QAAUD,EAAa,EACvB,QAAmB,CAAC,EAErC,SAASE,EAAc,CACtB,KAAK,QAAQ,OAAOA,EAAM,KAAMA,CAAK,EACrC,KAAK,QAAQ,KAAKA,CAAK,CACxB,CAEA,KAAKC,EAA2B,CAC/BJ,EAAO,MAAM,eAAeI,IAAO,EAGnC,MAAMC,EAAWD,EAAK,SAAS,GAAG,EAC5BD,EAAQ,KAAK,QAAQ,OAAOE,EAAWD,EAAK,UAAU,EAAGA,EAAK,QAAQ,GAAG,CAAC,EAAIA,CAAI,EAGxF,OAFAJ,EAAO,MAAM,8BAA+BG,CAAK,EAE5CA,EAIE,CACN,QAASA,EAAM,QACf,OAAQA,EAAM,OACd,KAAMA,EAAM,KACZ,MAAOE,EAAWC,EAAWF,CAAI,EAAI,CAAC,CACvC,EARQ,IAST,CAEA,YAAYA,EAAc,CACzB,KAAK,QAAQ,OAAOA,CAAI,EACxB,MAAMG,EAAa,KAAK,QAAQ,UAAWJ,GAAUA,EAAM,OAASC,CAAI,EACxE,KAAK,QAAQ,OAAOG,EAAY,CAAC,CAClC,CAEA,OAAQ,CACP,MAAO,CACN,IAAK,eACL,UAAW,KAAK,QAAQ,OACxB,OAAQ,KAAK,OACd,CACD,CACD,CAEA,MAAMD,EAAcF,GAAoD,CACvE,MAAMI,EAA2C,CAAC,EAG5CC,EAAUL,EAAK,UAAUA,EAAK,QAAQ,GAAG,EAAI,CAAC,EAAE,MAAM,GAAG,EAC/D,UAAWM,KAAaD,EAAS,CAChC,MAAME,EAAiBD,EAAU,QAAQ,GAAG,EACtCE,EAAMF,EAAU,UAAU,EAAGC,CAAc,EAE3CE,EADQH,EAAU,UAAUC,EAAiB,CAAC,GAC9B,MAAM,GAAG,GAAK,CAAC,EAC/BG,EAAU,MAAM,QAAQD,CAAM,EAEpC,GAAIC,EACH,QAASC,EAAI,EAAGA,EAAIF,EAAO,OAAQE,IAClCF,EAAOE,CAAC,EAAI,mBAAmBF,EAAOE,CAAC,CAAC,EAKtCD,GAAWD,EAAO,SAAW,EAChCL,EAAMI,CAAG,EAAIC,EAAO,CAAC,EAErBL,EAAMI,CAAG,EAAIC,EAIf,OAAOL,CACR","sourcesContent":["import { logger } from './logger.js'\nimport { createRouter } from './radix3.js'\nimport type { RouteHandler } from '../types/api.js'\n\ninterface Route {\n\thandler: RouteHandler\n\tpath: string\n}\n\ninterface RouteResult {\n\thandler: RouteHandler\n\tparams: Record<string, string>\n\tpath: string\n\tquery: Record<string, string | string[]>\n}\n\nexport class Router {\n\tprivate readonly _router = createRouter()\n\tprivate readonly _routes: Route[] = []\n\n\taddRoute(route: Route) {\n\t\tthis._router.insert(route.path, route)\n\t\tthis._routes.push(route)\n\t}\n\n\tfind(path: string): RouteResult {\n\t\tlogger.debug(`Router.find(${path})`)\n\n\t\t// Remove query params from the path to avoid param issues.\n\t\tconst hasQuery = path.includes('?')\n\t\tconst route = this._router.lookup(hasQuery ? path.substring(0, path.indexOf('?')) : path)\n\t\tlogger.debug('Found matching API Route...', route)\n\n\t\tif (!route) {\n\t\t\treturn null\n\t\t}\n\n\t\treturn {\n\t\t\thandler: route.handler as RouteHandler,\n\t\t\tparams: route.params as Record<string, string>,\n\t\t\tpath: route.path as string,\n\t\t\tquery: hasQuery ? parseQuery(path) : {}\n\t\t}\n\t}\n\n\tremoveRoute(path: string) {\n\t\tthis._router.remove(path)\n\t\tconst routeIndex = this._routes.findIndex((route) => route.path === path)\n\t\tthis._routes.splice(routeIndex, 1)\n\t}\n\n\tstats() {\n\t\treturn {\n\t\t\tkey: 'radix-router',\n\t\t\tnumRoutes: this._routes.length,\n\t\t\troutes: this._routes\n\t\t}\n\t}\n}\n\nconst parseQuery = (path: string): Record<string, string | string[]> => {\n\tconst query: Record<string, string | string[]> = {}\n\n\t// Parse out queries!\n\tconst queries = path.substring(path.indexOf('?') + 1).split('&')\n\tfor (const queryPair of queries) {\n\t\tconst queryPairSplit = queryPair.indexOf('=')\n\t\tconst key = queryPair.substring(0, queryPairSplit)\n\t\tconst value = queryPair.substring(queryPairSplit + 1)\n\t\tconst result = value?.split(',') ?? []\n\t\tconst isArray = Array.isArray(result)\n\n\t\tif (isArray) {\n\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\tresult[i] = decodeURIComponent(result[i])\n\t\t\t}\n\t\t}\n\n\t\t// Don't store as array if there's only one value\n\t\tif (isArray && result.length === 1) {\n\t\t\tquery[key] = result[0]\n\t\t} else {\n\t\t\tquery[key] = result\n\t\t}\n\t}\n\n\treturn query\n}\n"]}