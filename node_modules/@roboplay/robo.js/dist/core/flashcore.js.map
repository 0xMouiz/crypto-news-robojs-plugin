{"version":3,"sources":["../../src/core/flashcore.ts"],"names":["getConfig","FlashcoreFileAdapter","logger","_adapter","_watchers","Flashcore","key","oldValue","callback","value","prepareFlashcore","config","Keyv","keyv","error"],"mappings":"AAAA,OAAS,aAAAA,MAAiB,cAC1B,OAAS,wBAAAC,MAA4B,oBACrC,OAAS,UAAAC,MAAc,cAMvB,IAAIC,EAGJ,MAAMC,EAAY,IAAI,IAETC,EAAY,CAMxB,MAAO,IACCF,EAAS,MAAM,EASvB,OAASG,GAA4C,CACpD,GAAIF,EAAU,IAAIE,CAAG,EAAG,CACvB,MAAMC,EAAWJ,EAAS,IAAIG,CAAG,EACjC,GAAIC,aAAoB,QAGvB,OAAOA,EACL,KAAMA,GAAa,CACnBH,EAAU,IAAIE,CAAG,EAAE,QAASE,GAAaA,EAASD,EAAU,MAAS,CAAC,CACvE,CAAC,EACA,KAAK,IAAMJ,EAAS,OAAOG,CAAG,CAAC,EAC/B,MAAM,IAAMH,EAAS,OAAOG,CAAG,CAAC,EAElCF,EAAU,IAAIE,CAAG,EAAE,QAASE,GAAaA,EAASD,EAAU,MAAS,CAAC,EAIxE,OAAOJ,EAAS,OAAOG,CAAG,CAC3B,EASA,IAASA,GACDH,EAAS,IAAIG,CAAG,EAUxB,IAAK,CAACA,EAAaE,IAA+B,CAC7CJ,EAAU,IAAIE,CAAG,GAAKE,GACzBJ,EAAU,IAAIE,CAAG,GAAG,OAAOE,CAAQ,EAE/BJ,EAAU,IAAIE,CAAG,GAAG,OAAS,GAChCF,EAAU,OAAOE,CAAG,GAEXF,EAAU,IAAIE,CAAG,GAC3BF,EAAU,OAAOE,CAAG,CAEtB,EAUA,GAAI,CAACA,EAAaE,IAA8B,CAC1CJ,EAAU,IAAIE,CAAG,GACrBF,EAAU,IAAIE,EAAK,IAAI,GAAK,EAG7BF,EAAU,IAAIE,CAAG,GAAG,IAAIE,CAAQ,CACjC,EAUA,IAAK,CAAIF,EAAaG,IAAyC,CAC9D,GAAIL,EAAU,IAAIE,CAAG,EAAG,CACvB,MAAMC,EAAWJ,EAAS,IAAIG,CAAG,EACjC,GAAIC,aAAoB,QAGvB,OAAOA,EACL,KAAMA,GAAa,CACnBH,EAAU,IAAIE,CAAG,EAAE,QAASE,GAAaA,EAASD,EAAUE,CAAK,CAAC,CACnE,CAAC,EACA,KAAK,IAAMN,EAAS,IAAIG,EAAKG,CAAK,CAAC,EACnC,MAAM,IAAMN,EAAS,IAAIG,EAAKG,CAAK,CAAC,EAEtCL,EAAU,IAAIE,CAAG,EAAE,QAASE,GAAaA,EAASD,EAAUE,CAAK,CAAC,EAIpE,OAAON,EAAS,IAAIG,EAAKG,CAAK,CAC/B,CACD,EAEA,eAAsBC,GAAmB,CACxC,MAAMC,EAASX,EAAU,EAEzB,GAAIW,EAAO,WAAW,KACrB,GAAI,CACHT,EAAO,MAAM,8BAA8B,EAC3C,MAAMU,GAAQ,KAAM,QAAO,MAAM,GAAG,QAC9BC,EAAO,IAAID,EAAKD,EAAO,UAAU,IAAI,EAE3CE,EAAK,GAAG,QAAUC,GAAU,CAC3BZ,EAAO,MAAM,cAAeY,CAAK,CAClC,CAAC,EACDX,EAAWU,CACZ,OAASC,EAAP,CACD,MAAAZ,EAAO,MAAMY,CAAK,EACZ,IAAI,MAAM,0DAA0D,CAC3E,MAEAX,EAAW,IAAIF,EACf,MAAOE,EAAkC,KAAK,CAEhD","sourcesContent":["import { getConfig } from './config.js'\nimport { FlashcoreFileAdapter } from './flashcore-fs.js'\nimport { logger } from './logger.js'\nimport type { FlashcoreAdapter } from '../types/index.js'\n\ntype WatcherCallback<V = unknown> = (oldValue: V, newValue: V) => void | Promise<void>\n\n// Store that powers the Flashcore API.\nlet _adapter: FlashcoreAdapter | undefined\n\n// Watchers for listening to changes in the store.\nconst _watchers = new Map<string, Set<WatcherCallback>>()\n\nexport const Flashcore = {\n\t/**\n\t * Clears all key-value pairs from the store.\n\t *\n\t * @returns {Promise<boolean> | boolean} - Resolves to a boolean indicating whether the operation was successful.\n\t */\n\tclear: (): Promise<boolean> | Promise<void> | boolean | void => {\n\t\treturn _adapter.clear()\n\t},\n\n\t/**\n\t * Deletes the value associated with a key from the store.\n\t *\n\t * @param {string} key - The key associated with the value to delete.\n\t * @returns {Promise<boolean> | boolean} - Resolves to a boolean indicating whether the operation was successful.\n\t */\n\tdelete: (key: string): Promise<boolean> | boolean => {\n\t\tif (_watchers.has(key)) {\n\t\t\tconst oldValue = _adapter.get(key)\n\t\t\tif (oldValue instanceof Promise) {\n\t\t\t\t// Return as promise to avoid race condition fetching the old value.\n\t\t\t\t// I believe this is ideal, as promise-based values are likely to be used with async/await.\n\t\t\t\treturn oldValue\n\t\t\t\t\t.then((oldValue) => {\n\t\t\t\t\t\t_watchers.get(key).forEach((callback) => callback(oldValue, undefined))\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => _adapter.delete(key))\n\t\t\t\t\t.catch(() => _adapter.delete(key))\n\t\t\t} else {\n\t\t\t\t_watchers.get(key).forEach((callback) => callback(oldValue, undefined))\n\t\t\t}\n\t\t}\n\n\t\treturn _adapter.delete(key)\n\t},\n\n\t/**\n\t * Gets the value associated with a key.\n\t *\n\t * @template V - The type of the value.\n\t * @param {string} key - The key associated with the value.\n\t * @returns {Promise<V> | V} - May return a promise you can await or the value directly.\n\t */\n\tget: <V>(key: string): Promise<V> | V => {\n\t\treturn _adapter.get(key) as V\n\t},\n\n\t/**\n\t * Unregisters a callback from a key, so it will no longer be executed when the key's value changes.\n\t *\n\t * @param {string} key - The key to stop watching.\n\t * @param {WatcherCallback} callback - The callback function to remove from the key's watch list.\n\t * If no callback is provided, all callbacks associated with the key are removed.\n\t */\n\toff: (key: string, callback?: WatcherCallback) => {\n\t\tif (_watchers.has(key) && callback) {\n\t\t\t_watchers.get(key)?.delete(callback)\n\n\t\t\tif (_watchers.get(key)?.size === 0) {\n\t\t\t\t_watchers.delete(key)\n\t\t\t}\n\t\t} else if (_watchers.has(key)) {\n\t\t\t_watchers.delete(key)\n\t\t}\n\t},\n\n\t/**\n\t * Registers a callback to be executed when a specific key's value changes in the store.\n\t *\n\t * @template V - The type of the value.\n\t * @param {string} key - The key to watch for changes.\n\t * @param {WatcherCallback} callback - The callback function to execute when the key's value changes.\n\t * The callback receives the new and old values as arguments.\n\t */\n\ton: (key: string, callback: WatcherCallback) => {\n\t\tif (!_watchers.has(key)) {\n\t\t\t_watchers.set(key, new Set())\n\t\t}\n\n\t\t_watchers.get(key)?.add(callback)\n\t},\n\n\t/**\n\t * Sets a key-value pair in the store.\n\t *\n\t * @template V - The type of the value.\n\t * @param {string} key - The key to associate with the value.\n\t * @param {V} value - The value to set.\n\t * @returns {Promise<boolean> | boolean} - Resolves to a boolean indicating whether the operation was successful.\n\t */\n\tset: <V>(key: string, value: V): Promise<boolean> | boolean => {\n\t\tif (_watchers.has(key)) {\n\t\t\tconst oldValue = _adapter.get(key)\n\t\t\tif (oldValue instanceof Promise) {\n\t\t\t\t// Return as promise to avoid race condition fetching the old value.\n\t\t\t\t// I believe this is ideal, as promise-based values are likely to be used with async/await.\n\t\t\t\treturn oldValue\n\t\t\t\t\t.then((oldValue) => {\n\t\t\t\t\t\t_watchers.get(key).forEach((callback) => callback(oldValue, value))\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => _adapter.set(key, value))\n\t\t\t\t\t.catch(() => _adapter.set(key, value))\n\t\t\t} else {\n\t\t\t\t_watchers.get(key).forEach((callback) => callback(oldValue, value))\n\t\t\t}\n\t\t}\n\n\t\treturn _adapter.set(key, value)\n\t}\n}\n\nexport async function prepareFlashcore() {\n\tconst config = getConfig()\n\n\tif (config.flashcore?.keyv) {\n\t\ttry {\n\t\t\tlogger.debug(`Using Keyv Flashcore adapter`)\n\t\t\tconst Keyv = (await import('keyv')).default\n\t\t\tconst keyv = new Keyv(config.flashcore.keyv)\n\n\t\t\tkeyv.on('error', (error) => {\n\t\t\t\tlogger.error(`Keyv error:`, error)\n\t\t\t})\n\t\t\t_adapter = keyv\n\t\t} catch (error) {\n\t\t\tlogger.error(error)\n\t\t\tthrow new Error('Failed to import or setup the adapter with keyv package.')\n\t\t}\n\t} else {\n\t\t_adapter = new FlashcoreFileAdapter()\n\t\tawait (_adapter as FlashcoreFileAdapter).init()\n\t}\n}\n"]}