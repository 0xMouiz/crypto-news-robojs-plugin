import { color } from './color.js';
import { registerProcessEvents } from './process.js';
import { Client, Events, Collection } from 'discord.js';
import { loadConfig, getConfig } from './config.js';
import { logger } from './logger.js';
import { loadManifest } from '../cli/utils/manifest.js';
import { env } from './env.js';
import { executeEventHandler, executeCommandHandler, executeAutocompleteHandler, executeContextHandler } from './handlers.js';
import { hasProperties } from '../cli/utils/utils.js';
import { prepareFlashcore } from './flashcore.js';
import E from './portal.js';
import m from './server.js';
import { isMainThread, parentPort } from 'node:worker_threads';

const U={restart:K,start:M,stop:H};let a,u,v;async function M(o){const{client:n,stateLoad:i}=o??{};registerProcessEvents();const[s]=await Promise.all([loadConfig(),loadManifest()]);logger({enabled:s?.logger?.enabled,level:s?.logger?.level}).debug("Starting Robo..."),i&&(logger.debug("Waiting for state..."),await i);const l=L();await prepareFlashcore(),a=n??new Client(s.clientOptions),u=await E.open(),await executeEventHandler(l,"_start",a);for(const t of u.events.keys()){const r=u.events.get(t).every(c=>c.auto);a.on(t,async(...c)=>{r||logger.event(`Event received: ${color.bold(t)}`),logger.trace("Event args:",c),executeEventHandler(l,t,...c);});}a.on(Events.InteractionCreate,async t=>{if(t.isChatInputCommand()){const r=b(t);logger.event(`Received slash command interaction: ${color.bold("/"+r)}`),logger.trace("Slash command interaction:",t.toJSON()),await executeCommandHandler(t,r);}else if(t.isAutocomplete()){const r=b(t);logger.event(`Received autocomplete interaction for: ${color.bold(t.commandName)}`),logger.trace("Autocomplete interaction:",t.toJSON()),await executeAutocompleteHandler(t,r);}else t.isContextMenuCommand()&&(logger.event(`Received context menu interaction: ${color.bold(t.commandName)}`),logger.trace("Context menu interaction:",t.toJSON()),await executeContextHandler(t,t.commandName));}),u.apis.size>0&&await m.start(),await a.login(env.discord.token);}async function H(o=0){try{await executeEventHandler(v,"_stop",a),a?.destroy(),m.isRunning()&&await m.stop(),logger.debug("Stopped Robo at "+new Date().toLocaleString());}finally{isMainThread||(await logger.flush(),parentPort?.postMessage({event:"stop",payload:"exit"}),parentPort?.close()),process.exit(o);}}async function K(){try{await executeEventHandler(v,"_restart",a),a?.destroy(),m.isRunning()&&await m.stop(),logger.debug("Restarted Robo at "+new Date().toLocaleString());}finally{isMainThread?process.exit(0):(await logger.flush(),parentPort?.postMessage({event:"stop",payload:"exit"}),parentPort?.close(),process.exit());}}function b(o){const n=[o.commandName];if(hasProperties(o.options,["getSubcommandGroup"]))try{n.push(o.options.getSubcommandGroup());}catch{}if(hasProperties(o.options,["getSubcommand"]))try{n.push(o.options.getSubcommand());}catch{}return n.filter(Boolean).join(" ")}function L(){const o=getConfig(),n=new Collection;if(!o.plugins)return n;for(const i of o.plugins)if(typeof i=="string")n.set(i,{name:i});else if(Array.isArray(i)){const[s,l,t]=i;n.set(s,{name:s,options:l,metaOptions:t});}return n}

export { U as Robo, a as client, u as portal };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=robo.js.map