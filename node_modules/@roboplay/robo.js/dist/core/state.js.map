{"version":3,"sources":["../../src/core/state.ts"],"names":["FLASHCORE_KEYS","logger","Flashcore","state","State","prefix","options","key","getState","value","setState","builtInTypes","removeInstances","warned","item","result","processedValue","clearState","getStateSave","botProcess","resolve","reject","messageListener","message","isStateMessage","error","loadState","savedState","saveState","persist","persistedState"],"mappings":"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","sourcesContent":["import { FLASHCORE_KEYS } from './constants.js'\nimport { logger } from './logger.js'\nimport { Flashcore } from './flashcore.js'\nimport type { RoboMessage, RoboStateMessage } from '../types/index.js'\nimport type { ChildProcess } from 'child_process'\n\nexport const state: Record<string, unknown> = {}\n\ninterface SetStateOptions {\n\tpersist?: boolean\n}\n\ninterface StateOptions {\n\tpersist?: boolean\n}\n\nexport class State {\n\tprivate static readonly _prefixes = new Set<string>()\n\n\tprivate readonly _prefix: string\n\tprivate readonly _options?: StateOptions\n\n\tconstructor(prefix: string, options?: StateOptions) {\n\t\tthis._prefix = prefix\n\t\tthis._options = options\n\t\tthis.fork = this.fork.bind(this)\n\t\tthis.getState = this.getState.bind(this)\n\t\tthis.setState = this.setState.bind(this)\n\t}\n\n\t/**\n\t * Creates a new state fork.\n\t * This is useful for preventing state collisions between different parts of the Robo.\n\t *\n\t * @param prefix Fork prefix (e.g. 'polls')\n\t * @param options Options for the fork (persisting all state by default)\n\t * @returns A new state fork you can deconstruct (e.g. `const { getState, setState } = State.fork('polls')`\n\t */\n\tstatic fork(prefix: string, options?: StateOptions) {\n\t\tState._prefixes.add(prefix)\n\t\treturn new State(prefix, options)\n\t}\n\n\tstatic listForks() {\n\t\treturn new Array(...State._prefixes)\n\t}\n\n\tfork(prefix: string, options?: StateOptions) {\n\t\treturn new State(`${this._prefix}__${prefix}`, options)\n\t}\n\n\t/**\n\t * Get a value from the forked state.\n\t * If the value does not exist, null is returned.\n\t *\n\t * @param key The key to get the value for.\n\t * @returns The value for the given key, or null if the key does not exist.\n\t */\n\tgetState<T = string>(key: string): T | null {\n\t\treturn getState<T>(`${this._prefix}__${key}`)\n\t}\n\n\t/**\n\t * Set a value in the forked state.\n\t * When the persist option is set to true, the state will be persisted to disk.\n\t *\n\t * @param key The key to set the value for.\n\t * @param value The value to set.\n\t * @param options Options for setting the state. (Persisting to disk)\n\t */\n\tsetState<T>(key: string, value: T, options?: SetStateOptions): void {\n\t\tsetState(`${this._prefix}__${key}`, value, {\n\t\t\t...(options ?? {}),\n\t\t\tpersist: options?.persist ?? this._options?.persist\n\t\t})\n\t}\n}\n\nconst builtInTypes = ['String', 'Number', 'Boolean', 'Array', 'Object']\n\n/**\n * Class instances are not serializable.\n * This function removes them from the state while preserving the rest of the state.\n */\nexport function removeInstances(value: unknown, warned = { value: false }): unknown {\n\tif (typeof value === 'function') {\n\t\treturn undefined\n\t}\n\n\tif (value !== null && typeof value === 'object') {\n\t\tif (!builtInTypes.includes(value.constructor.name)) {\n\t\t\tif (!warned.value) {\n\t\t\t\tlogger.warn('Removed state value as it is not serializable:', value)\n\t\t\t\twarned.value = true\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t} else if (Array.isArray(value)) {\n\t\t\treturn value.map((item) => removeInstances(item, warned)).filter((item) => item !== undefined)\n\t\t} else {\n\t\t\tconst result: Record<string, unknown> = {}\n\n\t\t\tfor (const key in value as Record<string, unknown>) {\n\t\t\t\tconst processedValue = removeInstances((value as Record<string, unknown>)[key], warned)\n\t\t\t\tif (processedValue !== undefined) {\n\t\t\t\t\tresult[key] = processedValue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result\n\t\t}\n\t}\n\n\treturn value\n}\n\nexport function clearState(): void {\n\tObject.keys(state).forEach((key) => {\n\t\tdelete state[key]\n\t})\n}\n\n/**\n * Get a value from the state.\n * If the value does not exist, null is returned.\n *\n * @param key The key to get the value for.\n * @returns The value for the given key, or null if the key does not exist.\n */\nexport function getState<T = string>(key: string): T | null {\n\treturn state[key] as T | null\n}\n\nexport function getStateSave(botProcess: ChildProcess | null): Promise<Record<string, unknown>> {\n\tif (!botProcess) {\n\t\treturn Promise.resolve({})\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst messageListener = (message: RoboMessage) => {\n\t\t\t// Check for the specific type of message we're waiting for\n\t\t\tif (isStateMessage(message)) {\n\t\t\t\tbotProcess.off('message', messageListener)\n\t\t\t\tresolve(message.state)\n\t\t\t}\n\t\t}\n\n\t\tbotProcess.on('message', messageListener)\n\n\t\tbotProcess.once('error', (error) => {\n\t\t\tbotProcess.off('message', messageListener)\n\t\t\treject(error)\n\t\t})\n\n\t\tbotProcess.send({ type: 'state-save' })\n\t})\n}\n\nfunction isStateMessage(message: RoboMessage): message is RoboStateMessage {\n\treturn message.type === 'state-load' || message.type === 'state-save'\n}\n\nexport function loadState(savedState: Record<string, unknown>) {\n\tlogger.debug(`Loading state...`, savedState)\n\tObject.keys(savedState).forEach((key) => {\n\t\tstate[key] = savedState[key]\n\t})\n}\n\nexport function saveState() {\n\tlogger.debug(`Saving state...`, state)\n\tprocess.send({ type: 'state-save', state })\n}\n\n/**\n * Set a value in the state.\n * When the persist option is set to true, the state will be persisted to disk.\n *\n * @param key The key to set the value for.\n * @param value The value to set.\n * @param options Options for setting the state. (Persisting to disk)\n */\nexport function setState<T>(key: string, value: T, options?: SetStateOptions): void {\n\tconst { persist } = options ?? {}\n\tstate[key] = value\n\n\t// Persist state to disk if requested\n\tif (persist) {\n\t\tconst persistState = async () => {\n\t\t\tconst persistedState = (await Flashcore.get<Record<string, unknown>>(FLASHCORE_KEYS.state)) ?? {}\n\t\t\tpersistedState[key] = value\n\t\t\tFlashcore.set(FLASHCORE_KEYS.state, persistedState)\n\t\t}\n\t\tpersistState()\n\t}\n}\n"]}