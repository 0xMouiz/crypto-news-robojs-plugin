import { portal } from './robo.js';
import { timeout, getSage } from '../cli/utils/utils.js';
import { getConfig } from './config.js';
import { logger } from './logger.js';
import { BUFFER, TIMEOUT, DEFAULT_CONFIG } from './constants.js';
import { printErrorResponse } from './debug.js';
import { color } from './color.js';
import c from 'node:path';

async function H(o,i){const t=portal.commands.get(i);if(!t){logger.error(`No command matching ${i} was found.`);return}if(!portal.module(t.module).isEnabled){logger.debug(`Tried to execute disabled command from module: ${color.bold(t.module)}`);return}try{for(const a of portal.middleware){logger.debug(`Executing middleware: ${color.bold(c.join(a.plugin?.path??".",a.path))}`);const m=await a.handler.default({payload:[o],record:t});if(m&&m.abort){logger.debug(`Middleware aborted autocomplete: ${color.bold(o.commandName)}`);return}}}catch(a){logger.error("Aborting due to middleware error:",a);return}const f=getConfig();try{logger.debug(`Executing autocomplete handler: ${color.bold(c.join(t.plugin?.path??".",t.path))}`);const a=[t.handler.autocomplete(o)],m=f?.timeouts?.autocomplete;m&&a.push(timeout(()=>[],m));const e=await Promise.race(a);if(!e)throw new Error("Autocomplete timed out");await o.respond(e);}catch(a){logger.error("Autocomplete error:",a);}}async function O(o,i){const t=portal.commands.get(i);if(!t){logger.error(`No command matching "${i}" was found.`);return}if(!portal.module(t.module).isEnabled){logger.debug(`Tried to execute disabled command from module: ${color.bold(t.module)}`);return}try{for(const e of portal.middleware){logger.debug(`Executing middleware: ${color.bold(c.join(e.plugin?.path??".",e.path))}`);const d=await e.handler.default({payload:[o],record:t});if(d&&d.abort){logger.debug(`Middleware aborted command: ${color.bold(i)}`);return}}}catch(e){logger.error("Aborting due to middleware error:",e);return}const f=t.handler.config,a=getConfig(),m=getSage(f,a);logger.debug("Sage options:",m);try{if(logger.debug(`Executing command handler: ${color.bold(c.join(t.plugin?.path??".",t.path))}`),!t.handler.default)throw `Missing default export function for command: ${color.bold("/"+i)}`;const e=t.handler.default(o),d=[];let s;if(m.defer&&e instanceof Promise){const g=timeout(()=>BUFFER,m.deferBuffer),b=await Promise.race([e,g]);if(b===BUFFER&&!o.replied){if(logger.debug("Sage is deferring async command..."),d.push(e),!o.deferred)try{await o.deferReply({ephemeral:m.ephemeral});}catch(p){const $=p instanceof Error?p.message:p;if(!$.includes("Unknown interaction")&&!$.includes("Interaction has already been acknowledged"))throw p;logger.debug("Interaction was already handled, skipping Sage deferral");}}else s=b;}if(d.length>0){if(a?.timeouts?.commandDeferral&&d.push(timeout(()=>TIMEOUT,a.timeouts.commandDeferral)),s=await Promise.race(d),s===TIMEOUT)throw new Error("Command timed out")}else e instanceof Promise||(s=e);if(s===void 0){logger.debug("Command returned void, skipping response");return}logger.debug("Sage is handling reply:",s);const n=typeof s=="string"?{content:s}:s;o.deferred?await o.editReply(n):await o.reply(n);}catch(e){logger.error(e),printErrorResponse(e,o);}}async function B(o,i){const t=portal.context.get(i);if(!t){logger.error(`No context menu command matching "${i}" was found.`);return}if(!portal.module(t.module).isEnabled){logger.debug(`Tried to execute disabled context menu command from module: ${color.bold(t.module)}`);return}try{for(const e of portal.middleware){logger.debug(`Executing middleware: ${color.bold(c.join(e.plugin?.path??".",e.path))}`);const d=await e.handler.default({payload:[o],record:t});if(d&&d.abort){logger.debug(`Middleware aborted context command: ${color.bold(i)}`);return}}}catch(e){logger.error("Aborting due to middleware error:",e);return}const f=t.handler.config,a=getConfig(),m=getSage(f,a);logger.debug("Sage options:",m);try{if(logger.debug(`Executing context menu handler: ${color.bold(c.join(t.plugin?.path??".",t.path))}`),!t.handler.default)throw `Missing default export function for command: ${color.bold("/"+i)}`;let e;o.isMessageContextMenuCommand()?e=o.targetMessage:o.isUserContextMenuCommand()&&(e=o.targetUser);const d=t.handler.default(o,e),s=[];let n;if(m.defer&&d instanceof Promise){const b=timeout(()=>BUFFER,m.deferBuffer),p=await Promise.race([d,b]);p===BUFFER&&!o.replied?(logger.debug("Sage is deferring async command..."),s.push(d),o.deferred||await o.deferReply({ephemeral:m.ephemeral})):n=p;}if(s.length>0){if(a?.timeouts?.commandDeferral&&s.push(timeout(()=>TIMEOUT,a.timeouts.commandDeferral)),n=await Promise.race(s),n===TIMEOUT)throw new Error("Context menu command timed out")}else d instanceof Promise||(n=d);if(n===void 0){logger.debug("Context menu command returned void, skipping response");return}logger.debug("Sage is handling reply:",n);const g=typeof n=="string"?{content:n}:n;o.deferred?await o.editReply(g):await o.reply(g);}catch(e){logger.error(e),printErrorResponse(e,o);}}async function _(o,i,...t){const f=portal.events.get(i);if(!f?.length)return Promise.resolve();const a=getConfig(),m=i.startsWith("_");await Promise.all(f.map(async e=>{try{if(logger.debug(`Executing event handler: ${color.bold(c.join(e.plugin?.path??".",e.path))}`),!e.handler.default)throw `Missing default export function for event: ${color.bold(i)}`;if(!portal.module(e.module).isEnabled){logger.debug(`Tried to execute disabled event from module: ${color.bold(e.module)}`);return}try{for(const n of portal.middleware){logger.debug(`Executing middleware: ${color.bold(c.join(n.plugin?.path??".",n.path))}`);const g=await n.handler.default({payload:t,record:e});if(g&&g.abort){logger.debug(`Middleware aborted event: ${color.bold(i)}`);return}}}catch(n){logger.error("Aborting due to middleware error:",n);return}const d=e.handler.default(...t,o?.get(e.plugin?.name)?.options);if(!m)return await d;const s=timeout(()=>TIMEOUT,a?.timeouts?.lifecycle||DEFAULT_CONFIG.timeouts.lifecycle);return await Promise.race([d,s])}catch(d){try{const s=o?.get(e.plugin?.name)?.metaOptions??{};let n;d===TIMEOUT?(n=`${i} lifecycle event handler timed out`,logger.warn(n)):e.plugin?i==="_start"&&s.failSafe?(n=`${e.plugin.name} plugin failed to start`,logger.warn(n,d)):(n=`${e.plugin.name} plugin error in event ${i}`,logger.error(n,d)):(n=`Error executing ${i} event handler`,logger.error(n,d)),printErrorResponse(d,t[0],n,e);}catch(s){logger.error("Error handling event error...",s);}}}));}

export { H as executeAutocompleteHandler, O as executeCommandHandler, B as executeContextHandler, _ as executeEventHandler };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=handlers.js.map