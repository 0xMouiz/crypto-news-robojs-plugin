{"version":3,"sources":["../../src/core/server.ts"],"names":["http","url","parse","Router","logger","portal","color","composeColors","MAX_BODY_SIZE","_isRunning","_router","_server","Server","port","resolve","api","req","res","parsedUrl","body","getRequestBody","err","reqWrapper","reply","statusCode","data","name","value","route","result","error","server_default","reject","size","chunk","parsedBody"],"mappings":"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","sourcesContent":["import http, { IncomingMessage } from 'node:http'\nimport url from 'node:url'\nimport { parse } from 'node:querystring'\nimport { Router } from './router.js'\nimport { logger } from './logger.js'\nimport { portal } from './robo.js'\nimport { color, composeColors } from './color.js'\nimport type { HttpMethod, RoboReply, RoboRequest } from '../types/index.js'\n\nconst MAX_BODY_SIZE = 5 * 1024 * 1024 // 5MB\n\nlet _isRunning = false\nlet _router: Router | null = null\nlet _server: http.Server | null = null\n\nconst Server = {\n\tisRunning: () => _isRunning,\n\n\tstart: (port = 3000): Promise<void> => {\n\t\treturn new Promise((resolve) => {\n\t\t\tif (_server) {\n\t\t\t\tlogger.warn('Server is already up and running. No action taken.')\n\t\t\t\tresolve()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Add loaded API modules onto new router instance\n\t\t\t_router = new Router()\n\t\t\tportal.apis.forEach((api) => {\n\t\t\t\t_router.addRoute({\n\t\t\t\t\thandler: api.handler.default,\n\t\t\t\t\tpath: '/api/' + api.key\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// Create server instance\n\t\t\t_server = http.createServer(async (req, res) => {\n\t\t\t\tconst parsedUrl = url.parse(req.url, true)\n\t\t\t\tlet body\n\t\t\t\tif (req.method === 'POST' || req.method === 'PUT' || req.method === 'PATCH') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbody = await getRequestBody(req)\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tlogger.error(`Error in parsing request body: ${err}`)\n\t\t\t\t\t\tres.statusCode = 400\n\t\t\t\t\t\tres.end('Invalid request body.')\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst reqWrapper: RoboRequest = {\n\t\t\t\t\treq,\n\t\t\t\t\tbody: body,\n\t\t\t\t\tmethod: req.method as HttpMethod,\n\t\t\t\t\tquery: parse(req.url || ''),\n\t\t\t\t\tparams: {} // to be filled by the route handler\n\t\t\t\t}\n\n\t\t\t\tconst reply: RoboReply = {\n\t\t\t\t\tres,\n\t\t\t\t\thasSent: false,\n\t\t\t\t\tcode: function (statusCode: number) {\n\t\t\t\t\t\tthis.res.statusCode = statusCode\n\t\t\t\t\t\treturn this\n\t\t\t\t\t},\n\t\t\t\t\tsend: function (data: string) {\n\t\t\t\t\t\tthis.res.end(data)\n\t\t\t\t\t\tthis.hasSent = true\n\t\t\t\t\t\treturn this\n\t\t\t\t\t},\n\t\t\t\t\theader: function (name: string, value: string) {\n\t\t\t\t\t\tthis.res.setHeader(name, value)\n\t\t\t\t\t\treturn this\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst route = _router.find(parsedUrl.pathname)\n\n\t\t\t\tif (!route?.handler) {\n\t\t\t\t\treply.code(404).send('API Route not found.')\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await route.handler(reqWrapper, reply)\n\t\t\t\t\tif (!reply.hasSent && result) {\n\t\t\t\t\t\treply.code(200).send(result.toString())\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.error(`API Route error: ${error}`)\n\t\t\t\t\tres.statusCode = 500\n\t\t\t\t\tres.end('Server encountered an error.')\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t_server.on('error', (error: Error) => logger.error(`Server error: ${error}`))\n\n\t\t\t_isRunning = true\n\t\t\t_server.listen(port, () => {\n\t\t\t\tlogger.ready(`ðŸš€ Server is live at ${composeColors(color.bold, color.underline)(`http://localhost:${port}`)}`)\n\t\t\t\tresolve()\n\t\t\t})\n\t\t})\n\t},\n\n\tstop: (): Promise<void> => {\n\t\treturn new Promise((resolve) => {\n\t\t\tif (!_server) {\n\t\t\t\tlogger.warn(`Server isn't running. Nothing to stop here.`)\n\t\t\t\tresolve()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t_server.close((err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.error(`Error stopping the server: ${err}`)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t_isRunning = false\n\t\t\t\t_router = null\n\t\t\t\t_server = null\n\t\t\t\tlogger.debug('Server has been stopped successfully.')\n\t\t\t\tresolve()\n\t\t\t})\n\t\t})\n\t}\n}\nexport default Server\n\nasync function getRequestBody(req: IncomingMessage): Promise<unknown> {\n\treturn new Promise((resolve, reject) => {\n\t\tlet body = ''\n\t\tlet size = 0\n\t\treq.on('data', (chunk) => {\n\t\t\tsize += chunk.length\n\t\t\tif (size > MAX_BODY_SIZE) {\n\t\t\t\treject(new Error('Request body is too large'))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbody += chunk\n\t\t})\n\t\treq.on('end', () => {\n\t\t\ttry {\n\t\t\t\tlet parsedBody\n\t\t\t\ttry {\n\t\t\t\t\tparsedBody = JSON.parse(body)\n\t\t\t\t} catch (err) {\n\t\t\t\t\treject(new Error('Invalid JSON data'))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tresolve(parsedBody)\n\t\t\t} catch (err) {\n\t\t\t\treject(err)\n\t\t\t}\n\t\t})\n\t})\n}\n"]}