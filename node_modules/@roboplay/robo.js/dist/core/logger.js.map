{"version":3,"sources":["../../src/core/logger.ts"],"names":["inspect","color","env","DEBUG_MODE","ANSI_REGEX","pendingWrites","writeLog","stream","data","resolve","reject","parts","item","error","DEFAULT_MAX_ENTRIES","LogEntry","level","Logger","options","customLevels","enabled","LogLevelValues","key","value","label","colorizedLogLevels","promise","count","startIndex","recentLogs","_logger","logger"],"mappings":"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","sourcesContent":["import { inspect } from 'node:util'\nimport { color } from './color.js'\nimport { env } from './env.js'\n\nexport type LogLevel = 'trace' | 'debug' | 'info' | 'wait' | 'other' | 'event' | 'ready' | 'warn' | 'error'\n\ninterface CustomLevel {\n\tlabel: string\n\tpriority: number\n}\n\nexport interface LoggerOptions {\n\tcustomLevels?: Record<string, CustomLevel>\n\tenabled?: boolean\n\tlevel?: LogLevel | string\n\tmaxEntries?: number\n}\n\nexport const DEBUG_MODE = process.env.NODE_ENV !== 'production'\n\n// eslint-disable-next-line no-control-regex\nexport const ANSI_REGEX = /\\x1b\\[.*?m/g\n\nconst pendingWrites = new Set<Promise<void>>()\n\ntype LogStream = typeof process.stderr | typeof process.stdout\n\nfunction writeLog(stream: LogStream, ...data: unknown[]) {\n\treturn new Promise<void>((resolve, reject) => {\n\t\tconst parts = data?.map((item) => {\n\t\t\tif (typeof item === 'object' || item instanceof Error || Array.isArray(item)) {\n\t\t\t\treturn inspect(item, { colors: true, depth: null })\n\t\t\t}\n\t\t\treturn item\n\t\t})\n\n\t\tstream.write(parts?.join(' ') + '\\n', 'utf8', (error) => {\n\t\t\tif (error) reject(error)\n\t\t\telse resolve()\n\t\t})\n\t})\n}\n\nconst DEFAULT_MAX_ENTRIES = 100\n\nclass LogEntry {\n\tlevel: string\n\ttimestamp: Date\n\tdata: unknown[]\n\n\tconstructor(level: string, data: unknown[]) {\n\t\tthis.level = level\n\t\tthis.data = data\n\t\tthis.timestamp = new Date()\n\t}\n\n\tmessage(): string {\n\t\tconst messageParts = this.data.map((item) => {\n\t\t\tif (item instanceof Error) {\n\t\t\t\treturn item.message\n\t\t\t} else if (typeof item === 'object') {\n\t\t\t\ttry {\n\t\t\t\t\treturn JSON.stringify(item)\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// In case of circular structures or other stringify errors, return a fallback string\n\t\t\t\t\treturn '[unserializable object]'\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn item\n\t\t})\n\n\t\treturn messageParts.join(' ').replace(ANSI_REGEX, '')\n\t}\n}\n\nexport class Logger {\n\tprotected _customLevels: Record<string, CustomLevel>\n\tprotected _enabled: boolean\n\tprotected _level: LogLevel | string\n\tprotected _levelValues: Record<string, number>\n\tprivate _currentIndex: number\n\tprivate _logBuffer: LogEntry[]\n\n\tconstructor(options?: LoggerOptions) {\n\t\tconst { customLevels, enabled = true, level } = options ?? {}\n\n\t\tthis._customLevels = customLevels\n\t\tthis._enabled = enabled\n\t\tif (env.roboplay.host) {\n\t\t\t// This allows developers to have better control over the logs when hosted\n\t\t\tthis._level = 'trace'\n\t\t} else {\n\t\t\tthis._level = level ?? 'info'\n\t\t}\n\n\t\t// Combine the default log levels with the custom ones\n\t\tthis._levelValues = {\n\t\t\t...LogLevelValues,\n\t\t\t...Object.fromEntries(Object.entries(this._customLevels ?? {}).map(([key, value]) => [key, value.priority]))\n\t\t}\n\n\t\t// Initialize the log buffer\n\t\tthis._currentIndex = 0\n\t\tthis._logBuffer = new Array(options?.maxEntries ?? DEFAULT_MAX_ENTRIES)\n\t}\n\n\tprotected _log(level: string, ...data: unknown[]): void {\n\t\tif (this._enabled && this._levelValues[this._level] <= this._levelValues[level]) {\n\t\t\t// Format the message all pretty and stuff\n\t\t\tif (level !== 'other') {\n\t\t\t\tconst label = this._customLevels ? this._customLevels[level]?.label : colorizedLogLevels[level]\n\t\t\t\tdata.unshift((label ?? level.padEnd(5)) + ' -')\n\t\t\t}\n\n\t\t\t// Persist the log entry in debug mode\n\t\t\tif (DEBUG_MODE) {\n\t\t\t\tthis._logBuffer[this._currentIndex] = new LogEntry(level, data)\n\t\t\t\tthis._currentIndex = (this._currentIndex + 1) % this._logBuffer.length\n\t\t\t}\n\n\t\t\tlet promise: Promise<void>\n\t\t\tswitch (level) {\n\t\t\t\tcase 'trace':\n\t\t\t\tcase 'debug':\n\t\t\t\t\tpromise = writeLog(process.stdout, ...data)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'info':\n\t\t\t\t\tpromise = writeLog(process.stdout, ...data)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'wait':\n\t\t\t\t\tpromise = writeLog(process.stdout, ...data)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'event':\n\t\t\t\t\tpromise = writeLog(process.stdout, ...data)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'warn':\n\t\t\t\t\tpromise = writeLog(process.stderr, ...data)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'error':\n\t\t\t\t\tpromise = writeLog(process.stderr, ...data)\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tpromise = writeLog(process.stdout, ...data)\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tpendingWrites.add(promise)\n\t\t\tpromise.finally(() => {\n\t\t\t\tpendingWrites.delete(promise)\n\t\t\t})\n\t\t}\n\t}\n\n\tpublic flush() {\n\t\treturn Promise.allSettled([...pendingWrites])\n\t}\n\n\tpublic getRecentLogs(count = 50): LogEntry[] {\n\t\tif (count <= 0) {\n\t\t\treturn []\n\t\t}\n\n\t\t// Ensure the count doesn't exceed the number of logs in the buffer\n\t\tcount = Math.min(count, this._logBuffer.length)\n\t\tconst startIndex = (this._currentIndex - count + this._logBuffer.length) % this._logBuffer.length\n\t\tlet recentLogs: LogEntry[]\n\n\t\tif (startIndex < this._currentIndex) {\n\t\t\trecentLogs = this._logBuffer.slice(startIndex, this._currentIndex)\n\t\t} else {\n\t\t\trecentLogs = this._logBuffer.slice(startIndex).concat(this._logBuffer.slice(0, this._currentIndex))\n\t\t}\n\n\t\treturn recentLogs.reverse()\n\t}\n\n\tpublic trace(...data: unknown[]) {\n\t\tthis._log('trace', ...data)\n\t}\n\n\tpublic debug(...data: unknown[]) {\n\t\tthis._log('debug', ...data)\n\t}\n\n\tpublic info(...data: unknown[]) {\n\t\tthis._log('info', ...data)\n\t}\n\n\tpublic wait(...data: unknown[]) {\n\t\tthis._log('wait', ...data)\n\t}\n\n\tpublic log(...data: unknown[]) {\n\t\tthis._log('other', ...data)\n\t}\n\n\tpublic event(...data: unknown[]) {\n\t\tthis._log('event', ...data)\n\t}\n\n\tpublic ready(...data: unknown[]) {\n\t\tthis._log('ready', ...data)\n\t}\n\n\tpublic warn(...data: unknown[]) {\n\t\tthis._log('warn', ...data)\n\t}\n\n\tpublic error(...data: unknown[]) {\n\t\tthis._log('error', ...data)\n\t}\n\n\tpublic custom(level: string, ...data: unknown[]): void {\n\t\tif (this._customLevels?.[level]) {\n\t\t\tthis._log(level, ...data)\n\t\t}\n\t}\n}\n\nconst LogLevelValues: Record<string, number> = {\n\ttrace: 0,\n\tdebug: 1,\n\tinfo: 2,\n\twait: 3,\n\tother: 4,\n\tevent: 5,\n\tready: 6,\n\twarn: 7,\n\terror: 8\n}\n\nconst colorizedLogLevels: Record<string, string> = {\n\ttrace: color.gray('trace'.padEnd(5)),\n\tdebug: color.cyan('debug'.padEnd(5)),\n\tinfo: color.blue('info'.padEnd(5)),\n\twait: color.cyan('wait'.padEnd(5)),\n\tevent: color.magenta('event'.padEnd(5)),\n\tready: color.green('ready'.padEnd(5)),\n\twarn: color.yellow('warn'.padEnd(5)),\n\terror: color.red('error'.padEnd(5))\n}\n\nlet _logger: Logger | null = null\n\nexport function logger(options?: LoggerOptions): Logger {\n\tif (options) {\n\t\t_logger = new Logger(options)\n\t} else if (!_logger) {\n\t\t_logger = new Logger()\n\t}\n\n\treturn _logger\n}\n\nlogger.flush = async function (): Promise<void> {\n\tawait logger().flush()\n}\n\nlogger.getRecentLogs = function (count = 25): LogEntry[] {\n\treturn logger().getRecentLogs(count)\n}\n\nlogger.trace = function (...data: unknown[]): void {\n\treturn logger().trace(...data)\n}\n\nlogger.debug = function (...data: unknown[]): void {\n\treturn logger().debug(...data)\n}\n\nlogger.info = function (...data: unknown[]): void {\n\treturn logger().info(...data)\n}\n\nlogger.wait = function (...data: unknown[]): void {\n\treturn logger().wait(...data)\n}\n\nlogger.log = function (...data: unknown[]): void {\n\treturn logger().log(...data)\n}\n\nlogger.event = function (...data: unknown[]): void {\n\treturn logger().event(...data)\n}\n\nlogger.ready = function (...data: unknown[]): void {\n\treturn logger().ready(...data)\n}\n\nlogger.warn = function (...data: unknown[]): void {\n\treturn logger().warn(...data)\n}\n\nlogger.error = function (...data: unknown[]): void {\n\treturn logger().error(...data)\n}\n\nlogger.custom = function (level: string, ...data: unknown[]): void {\n\treturn logger().custom(level, ...data)\n}\n"]}