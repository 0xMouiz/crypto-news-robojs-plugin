{"version":3,"sources":["../../src/core/robo.ts"],"names":["color","registerProcessEvents","Client","Collection","Events","getConfig","loadConfig","logger","loadManifest","env","executeAutocompleteHandler","executeCommandHandler","executeContextHandler","executeEventHandler","hasProperties","prepareFlashcore","Portal","Server","isMainThread","parentPort","Robo","restart","start","stop","client","portal","plugins","options","optionsClient","stateLoad","config","loadPluginData","key","onlyAuto","event","args","interaction","commandKey","getCommandKey","exitCode","commandKeys","collection","plugin","name","metaOptions"],"mappings":"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","sourcesContent":["import { color } from './color.js'\nimport { registerProcessEvents } from './process.js'\nimport { Client, Collection, Events } from 'discord.js'\nimport { getConfig, loadConfig } from './config.js'\nimport { logger } from './logger.js'\nimport { loadManifest } from '../cli/utils/manifest.js'\nimport { env } from './env.js'\nimport {\n\texecuteAutocompleteHandler,\n\texecuteCommandHandler,\n\texecuteContextHandler,\n\texecuteEventHandler\n} from './handlers.js'\nimport { hasProperties } from '../cli/utils/utils.js'\nimport { prepareFlashcore } from './flashcore.js'\nimport Portal from './portal.js'\nimport Server from './server.js'\nimport { isMainThread, parentPort } from 'node:worker_threads'\nimport type { PluginData } from '../types/index.js'\nimport type { AutocompleteInteraction, CommandInteraction } from 'discord.js'\n\nexport const Robo = { restart, start, stop }\n\n// Each Robo instance has its own client, exported for convenience\nexport let client: Client\n\n// A Portal is exported with each Robo to allow for dynamic controls\nexport let portal: Portal\n\n// Be careful, plugins may contain sensitive data in their config\nlet plugins: Collection<string, PluginData>\n\ninterface StartOptions {\n\tclient?: Client\n\tstateLoad?: Promise<void>\n}\n\nasync function start(options?: StartOptions) {\n\tconst { client: optionsClient, stateLoad } = options ?? {}\n\n\t// Important! Register process events before doing anything else\n\t// This ensures the \"ready\" signal is sent to the parent process\n\tregisterProcessEvents()\n\n\t// Load config and manifest up next!\n\t// This makes them available globally via getConfig() and getManifest()\n\tconst [config] = await Promise.all([loadConfig(), loadManifest()])\n\tlogger({\n\t\tenabled: config?.logger?.enabled,\n\t\tlevel: config?.logger?.level\n\t}).debug('Starting Robo...')\n\n\t// Wait for states to be loaded\n\tif (stateLoad) {\n\t\tlogger.debug('Waiting for state...')\n\t\tawait stateLoad\n\t}\n\n\t// Load plugin options and start up Flashcore\n\tconst plugins = loadPluginData()\n\tawait prepareFlashcore()\n\n\t// Create the new client instance\n\tclient = optionsClient ?? new Client(config.clientOptions)\n\n\t// Load the portal (commands, context, events)\n\tportal = await Portal.open()\n\n\t// Notify lifecycle event handlers\n\tawait executeEventHandler(plugins, '_start', client)\n\n\t// Define event handlers\n\tfor (const key of portal.events.keys()) {\n\t\tconst onlyAuto = portal.events.get(key).every((event) => event.auto)\n\t\tclient.on(key, async (...args) => {\n\t\t\tif (!onlyAuto) {\n\t\t\t\tlogger.event(`Event received: ${color.bold(key)}`)\n\t\t\t}\n\t\t\tlogger.trace('Event args:', args)\n\n\t\t\t// Notify event handler\n\t\t\texecuteEventHandler(plugins, key, ...args)\n\t\t})\n\t}\n\n\t// Forward command interactions to our fancy handlers\n\tclient.on(Events.InteractionCreate, async (interaction) => {\n\t\tif (interaction.isChatInputCommand()) {\n\t\t\tconst commandKey = getCommandKey(interaction)\n\t\t\tlogger.event(`Received slash command interaction: ${color.bold('/' + commandKey)}`)\n\t\t\tlogger.trace('Slash command interaction:', interaction.toJSON())\n\t\t\tawait executeCommandHandler(interaction, commandKey)\n\t\t} else if (interaction.isAutocomplete()) {\n\t\t\tconst commandKey = getCommandKey(interaction)\n\t\t\tlogger.event(`Received autocomplete interaction for: ${color.bold(interaction.commandName)}`)\n\t\t\tlogger.trace('Autocomplete interaction:', interaction.toJSON())\n\t\t\tawait executeAutocompleteHandler(interaction, commandKey)\n\t\t} else if (interaction.isContextMenuCommand()) {\n\t\t\tlogger.event(`Received context menu interaction: ${color.bold(interaction.commandName)}`)\n\t\t\tlogger.trace('Context menu interaction:', interaction.toJSON())\n\t\t\tawait executeContextHandler(interaction, interaction.commandName)\n\t\t}\n\t})\n\n\t// Start HTTP server only if API Routes are defined\n\tif (portal.apis.size > 0) {\n\t\tawait Server.start()\n\t}\n\n\t// Log in to Discord with your client's token\n\tawait client.login(env.discord.token)\n}\n\nasync function stop(exitCode = 0) {\n\ttry {\n\t\t// Notify lifecycle handler\n\t\tawait executeEventHandler(plugins, '_stop', client)\n\t\tclient?.destroy()\n\t\tif (Server.isRunning()) {\n\t\t\tawait Server.stop()\n\t\t}\n\t\tlogger.debug(`Stopped Robo at ` + new Date().toLocaleString())\n\t} finally {\n\t\tif (isMainThread) {\n\t\t\tprocess.exit(exitCode)\n\t\t} else {\n\t\t\tawait logger.flush()\n\t\t\tparentPort?.postMessage({ event: 'stop', payload: 'exit' })\n\t\t\tparentPort?.close()\n\t\t\tprocess.exit(exitCode)\n\t\t}\n\t}\n}\n\nasync function restart() {\n\ttry {\n\t\t// Notify lifecycle handler\n\t\tawait executeEventHandler(plugins, '_restart', client)\n\t\tclient?.destroy()\n\t\tif (Server.isRunning()) {\n\t\t\tawait Server.stop()\n\t\t}\n\t\tlogger.debug(`Restarted Robo at ` + new Date().toLocaleString())\n\t} finally {\n\t\tif (isMainThread) {\n\t\t\tprocess.exit(0)\n\t\t} else {\n\t\t\tawait logger.flush()\n\t\t\tparentPort?.postMessage({ event: 'stop', payload: 'exit' })\n\t\t\tparentPort?.close()\n\t\t\tprocess.exit()\n\t\t}\n\t}\n}\n\nfunction getCommandKey(interaction: AutocompleteInteraction | CommandInteraction) {\n\tconst commandKeys = [interaction.commandName]\n\tif (hasProperties<{ getSubcommandGroup: () => string }>(interaction.options, ['getSubcommandGroup'])) {\n\t\ttry {\n\t\t\tcommandKeys.push(interaction.options.getSubcommandGroup())\n\t\t} catch {\n\t\t\t// Ignore\n\t\t}\n\t}\n\tif (hasProperties<{ getSubcommand: () => string }>(interaction.options, ['getSubcommand'])) {\n\t\ttry {\n\t\t\tcommandKeys.push(interaction.options.getSubcommand())\n\t\t} catch {\n\t\t\t// Ignore\n\t\t}\n\t}\n\treturn commandKeys.filter(Boolean).join(' ')\n}\n\nfunction loadPluginData() {\n\tconst config = getConfig()\n\tconst collection = new Collection<string, PluginData>()\n\tif (!config.plugins) {\n\t\treturn collection\n\t}\n\n\tfor (const plugin of config.plugins) {\n\t\tif (typeof plugin === 'string') {\n\t\t\tcollection.set(plugin, { name: plugin })\n\t\t} else if (Array.isArray(plugin)) {\n\t\t\tconst [name, options, metaOptions] = plugin\n\t\t\tcollection.set(name, { name, options, metaOptions })\n\t\t}\n\t}\n\n\treturn collection\n}\n"]}