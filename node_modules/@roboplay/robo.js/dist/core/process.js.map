{"version":3,"sources":["../../src/core/process.ts"],"names":["stateLoadResolve","stateLoad","resolve","registerProcessEvents","logger","Robo","message","saveState","loadState","reason","env","client","sendDebugError"],"mappings":"AAGA,IAAIA,EACG,MAAMC,EAAY,IAAI,QAAeC,GAAY,CACvDF,EAAmBE,CACpB,CAAC,EAWM,SAASC,GAAwB,CACvC,QAAQ,GAAG,SAAU,SAAY,CAChC,KAAM,CAAE,OAAAC,CAAO,EAAI,KAAM,QAAO,aAAa,EACvC,CAAE,KAAAC,CAAK,EAAI,KAAM,QAAO,WAAW,EAEzCD,EAAO,MAAM,yBAAyB,EACtCC,EAAK,KAAK,CACX,CAAC,EAED,QAAQ,GAAG,UAAW,SAAY,CACjC,KAAM,CAAE,OAAAD,CAAO,EAAI,KAAM,QAAO,aAAa,EACvC,CAAE,KAAAC,CAAK,EAAI,KAAM,QAAO,WAAW,EAEzCD,EAAO,MAAM,0BAA0B,EACvCC,EAAK,KAAK,CACX,CAAC,EAED,QAAQ,GAAG,UAAW,MAAOC,GAAyB,CACrD,KAAM,CAAE,OAAAF,CAAO,EAAI,KAAM,QAAO,aAAa,EACvC,CAAE,KAAAC,CAAK,EAAI,KAAM,QAAO,WAAW,EAGzC,GADAD,EAAO,MAAM,gCAAiCE,CAAO,EACjDA,GAAS,OAAS,UACrBD,EAAK,QAAQ,UACHC,GAAS,OAAS,aAAc,CAC1C,KAAM,CAAE,UAAAC,CAAU,EAAI,KAAM,QAAO,YAAY,EAC/CA,EAAU,UACAD,GAAS,OAAS,aAAc,CAC1C,KAAM,CAAE,UAAAE,CAAU,EAAI,KAAM,QAAO,YAAY,EAC/CA,EAAWF,EAA6B,KAAK,EAC7CN,EAAiB,OAEjBI,EAAO,MAAM,mBAAoBE,CAAO,CAE1C,CAAC,EAED,QAAQ,GAAG,qBAAsB,MAAOG,GAAW,CAClD,KAAM,CAAE,IAAAC,CAAI,EAAI,KAAM,QAAO,UAAU,EACjC,CAAE,OAAAN,CAAO,EAAI,KAAM,QAAO,aAAa,EACvC,CAAE,OAAAO,EAAQ,KAAAN,CAAK,EAAI,KAAM,QAAO,WAAW,EAWjD,GAPKM,GAAQ,QAAQ,IACpBP,EAAO,MAAMK,CAAM,EACnB,QAAQ,KAAK,CAAC,GAIfL,EAAO,MAAMK,CAAM,EACfC,EAAI,UAAY,aACnB,OAKD,KAAM,CAAE,eAAAE,CAAe,EAAI,KAAM,QAAO,YAAY,EAC/B,MAAMA,EAAeH,CAAM,GAE/CJ,EAAK,KAAK,CAAC,CAEb,CAAC,EAGD,QAAQ,OAAO,CAAE,KAAM,OAAQ,CAAC,EAGhC,WAAW,IAAM,CAChB,QAAQ,OAAO,CAAE,KAAM,QAAS,QAAS,EAAK,CAAC,CAChD,EAAG,GAAI,CACR","sourcesContent":["import type { RoboMessage, RoboStateMessage } from '../types/index.js'\n\n// This is used to wait for the state to be loaded before continuing\nlet stateLoadResolve: () => void\nexport const stateLoad = new Promise<void>((resolve) => {\n\tstateLoadResolve = resolve\n})\n\n/**\n * Registering process events ensure the \"ready\" signal is sent to the parent process.\n * Not doing this may cause the process to hang if any setup causes an error.\n * It's just as important to be able to receive messages from the parent process quickly.\n *\n * Note:\n * - Development mode waits for these events to be registered prior to continuing listening for changes.\n * - Imports are done inline to avoid potential crashes due to errors in them.\n */\nexport function registerProcessEvents() {\n\tprocess.on('SIGINT', async () => {\n\t\tconst { logger } = await import('./logger.js')\n\t\tconst { Robo } = await import('./robo.js')\n\n\t\tlogger.debug('Received SIGINT signal.')\n\t\tRobo.stop()\n\t})\n\n\tprocess.on('SIGTERM', async () => {\n\t\tconst { logger } = await import('./logger.js')\n\t\tconst { Robo } = await import('./robo.js')\n\n\t\tlogger.debug('Received SIGTERM signal.')\n\t\tRobo.stop()\n\t})\n\n\tprocess.on('message', async (message: RoboMessage) => {\n\t\tconst { logger } = await import('./logger.js')\n\t\tconst { Robo } = await import('./robo.js')\n\n\t\tlogger.debug('Received message from parent:', message)\n\t\tif (message?.type === 'restart') {\n\t\t\tRobo.restart()\n\t\t} else if (message?.type === 'state-save') {\n\t\t\tconst { saveState } = await import('./state.js')\n\t\t\tsaveState()\n\t\t} else if (message?.type === 'state-load') {\n\t\t\tconst { loadState } = await import('./state.js')\n\t\t\tloadState((message as RoboStateMessage).state)\n\t\t\tstateLoadResolve()\n\t\t} else {\n\t\t\tlogger.debug('Unknown message:', message)\n\t\t}\n\t})\n\n\tprocess.on('unhandledRejection', async (reason) => {\n\t\tconst { env } = await import('./env.js')\n\t\tconst { logger } = await import('./logger.js')\n\t\tconst { client, Robo } = await import('./robo.js')\n\n\t\t// Exit right away if the client isn't ready yet\n\t\t// We don't want to send a message to Discord nor notify handlers if we can't\n\t\tif (!client?.isReady()) {\n\t\t\tlogger.error(reason)\n\t\t\tprocess.exit(1)\n\t\t}\n\n\t\t// Log error and ignore it in production\n\t\tlogger.error(reason)\n\t\tif (env.nodeEnv === 'production') {\n\t\t\treturn\n\t\t}\n\n\t\t// Development mode works a bit differently because we don't want developers to ignore errors\n\t\t// Errors will stop the process unless there's a special channel to send them to\n\t\tconst { sendDebugError } = await import('./debug.js')\n\t\tconst handledError = await sendDebugError(reason)\n\t\tif (!handledError) {\n\t\t\tRobo.stop(1)\n\t\t}\n\t})\n\n\t// Tell the parent process we're ready to receive messages\n\tprocess.send?.({ type: 'ready' })\n\n\t// Backup message with delay to prevent race conditions\n\tsetTimeout(() => {\n\t\tprocess.send?.({ type: 'ready', delayed: true })\n\t}, 1000)\n}\n"]}