{"version":3,"sources":["../../src/core/portal.ts"],"names":["Collection","path","pathToFileURL","getManifest","hasProperties","logger","color","composeColors","hex","getConfig","Portal","apis","commands","context","events","middleware","api","command","event","handler","moduleName","moduleInstance","Module","loadHandlerRecords","_moduleName","_enabledModules","value","getPluginOptions","packageName","pluginOptions","plugin","scanEntries","predicate","options","manifestEntries","recursionKeys","type","promises","entryName","entryItem","entry","entryKeys","resursion","collection","manifest","pcolor","formatter","handlers","scanPredicate","basePath","importPath","eventKey","commandKey","contextKey"],"mappings":"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","sourcesContent":["import { Collection } from 'discord.js'\nimport path from 'node:path'\nimport { pathToFileURL } from 'node:url'\nimport { getManifest } from '../cli/utils/manifest.js'\nimport { hasProperties } from '../cli/utils/utils.js'\nimport { logger } from './logger.js'\nimport { color, composeColors, hex } from './color.js'\nimport type { Api, BaseConfig, Command, Context, Event, HandlerRecord, Middleware } from '../types/index.js'\nimport { getConfig } from './config.js'\n\nexport default class Portal {\n\tpublic apis: Collection<string, HandlerRecord<Api>>\n\tpublic commands: Collection<string, HandlerRecord<Command>>\n\tpublic context: Collection<string, HandlerRecord<Context>>\n\tpublic events: Collection<string, HandlerRecord<Event>[]>\n\tpublic middleware: HandlerRecord<Middleware>[] = []\n\tpublic moduleKeys = new Set<string>()\n\n\tprivate _enabledModules: Record<string, boolean> = {}\n\tprivate _modules: Record<string, Module> = {}\n\n\tconstructor(\n\t\tapis: Collection<string, HandlerRecord<Api>>,\n\t\tcommands: Collection<string, HandlerRecord<Command>>,\n\t\tcontext: Collection<string, HandlerRecord<Context>>,\n\t\tevents: Collection<string, HandlerRecord<Event>[]>,\n\t\tmiddleware: HandlerRecord<Middleware>[]\n\t) {\n\t\tthis.apis = apis\n\t\tthis.commands = commands\n\t\tthis.context = context\n\t\tthis.events = events\n\t\tthis.middleware = middleware\n\n\t\t// Generate module keys based off of entries then sort alphabetically\n\t\tapis.forEach((api) => {\n\t\t\tif (api.module) {\n\t\t\t\tthis.moduleKeys.add(api.module)\n\t\t\t}\n\t\t})\n\t\tcommands.forEach((command) => {\n\t\t\tif (command.module) {\n\t\t\t\tthis.moduleKeys.add(command.module)\n\t\t\t}\n\t\t})\n\t\tcontext.forEach((context) => {\n\t\t\tif (context.module) {\n\t\t\t\tthis.moduleKeys.add(context.module)\n\t\t\t}\n\t\t})\n\t\tevents.forEach((event) => {\n\t\t\tevent.forEach((handler) => {\n\t\t\t\tif (handler.module) {\n\t\t\t\t\tthis.moduleKeys.add(handler.module)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t\tmiddleware.forEach((middleware) => {\n\t\t\tif (middleware.module) {\n\t\t\t\tthis.moduleKeys.add(middleware.module)\n\t\t\t}\n\t\t})\n\t\tthis.moduleKeys = new Set([...this.moduleKeys].sort())\n\t}\n\n\tmodule(moduleName: string) {\n\t\tlet moduleInstance = this._modules[moduleName]\n\t\tif (!moduleInstance) {\n\t\t\tmoduleInstance = new Module(moduleName, this._enabledModules)\n\t\t\tthis._modules[moduleName] = moduleInstance\n\t\t}\n\t\treturn moduleInstance\n\t}\n\n\t/**\n\t * Creates a new Portal instance from the manifest file.\n\t *\n\t * Warning: Do not call this method directly. Use the `portal` export instead.\n\t */\n\tpublic static async open(): Promise<Portal> {\n\t\tconst apis = await loadHandlerRecords<HandlerRecord<Api>>('api')\n\t\tconst commands = await loadHandlerRecords<HandlerRecord<Command>>('commands')\n\t\tconst context = await loadHandlerRecords<HandlerRecord<Context>>('context')\n\t\tconst events = await loadHandlerRecords<HandlerRecord<Event>[]>('events')\n\t\tconst middleware = [...(await loadHandlerRecords<HandlerRecord<Middleware>>('middleware')).values()]\n\n\t\treturn new Portal(apis, commands, context, events, middleware)\n\t}\n}\n\nclass Module {\n\tconstructor(private _moduleName: string, private _enabledModules: Record<string, boolean>) {}\n\n\tget isEnabled(): boolean {\n\t\treturn this._enabledModules[this._moduleName] ?? true\n\t}\n\n\tsetEnabled(value: boolean) {\n\t\tthis._enabledModules[this._moduleName] = value\n\t}\n}\n\n/**\n * Gets the config options for a specific plugin package.\n *\n * @param packageName The name of the package to get the options for.\n * @returns The options for the package, or null if the package is not installed nor configured.\n */\nexport function getPluginOptions(packageName: string): unknown | null {\n\tconst config = getConfig()\n\tconst pluginOptions = config.plugins?.find((plugin) => {\n\t\treturn (typeof plugin === 'string' ? plugin : plugin[0]) === packageName\n\t})\n\tconst options = typeof pluginOptions === 'string' ? null : pluginOptions?.[1]\n\n\treturn options ?? null\n}\n\ninterface ScanOptions<T> {\n\tmanifestEntries: Record<string, T | T[]> | T[]\n\trecursionKeys?: string[]\n\ttype: string\n}\ntype ScanPredicate = <T>(entry: T, entryKeys: string[]) => Promise<void>\n\nasync function scanEntries<T>(predicate: ScanPredicate, options: ScanOptions<T>) {\n\tconst { manifestEntries, recursionKeys = [], type } = options\n\tconst promises: Promise<unknown>[] = []\n\n\tfor (const entryName in manifestEntries) {\n\t\tconst entryItem =\n\t\t\tArray.isArray(manifestEntries) && type !== 'middleware'\n\t\t\t\t? (manifestEntries as T[])\n\t\t\t\t: (manifestEntries as Record<string, T | T[]>)[entryName]\n\t\tconst entries = Array.isArray(entryItem) ? entryItem : [entryItem]\n\n\t\tentries.forEach((entry) => {\n\t\t\tconst entryKeys = [...recursionKeys, entryName]\n\t\t\tpromises.push(predicate(entry, entryKeys))\n\n\t\t\tif (hasProperties<{ subcommands: Record<string, T> }>(entry, ['subcommands']) && entry.subcommands) {\n\t\t\t\tconst resursion = scanEntries(predicate, {\n\t\t\t\t\tmanifestEntries: entry.subcommands,\n\t\t\t\t\trecursionKeys: entryKeys,\n\t\t\t\t\ttype\n\t\t\t\t})\n\t\t\t\tpromises.push(resursion)\n\t\t\t} else if (hasProperties<{ subroutes: Record<string, T> }>(entry, ['subroutes']) && entry.subroutes) {\n\t\t\t\tconst resursion = scanEntries(predicate, {\n\t\t\t\t\tmanifestEntries: entry.subroutes,\n\t\t\t\t\trecursionKeys: entryKeys,\n\t\t\t\t\ttype\n\t\t\t\t})\n\t\t\t\tpromises.push(resursion)\n\t\t\t}\n\t\t})\n\t}\n\n\treturn Promise.all(promises)\n}\n\nasync function loadHandlerRecords<T extends HandlerRecord | HandlerRecord[]>(\n\ttype: 'api' | 'commands' | 'context' | 'events' | 'middleware'\n) {\n\tconst collection = new Collection<string, T>()\n\tconst manifest = getManifest()\n\n\t// Log manifest objects as debug info\n\tconst pcolor =\n\t\ttype === 'commands'\n\t\t\t? composeColors(color.blue, color.bold)\n\t\t\t: type === 'context'\n\t\t\t? composeColors(hex('#536DFE'), color.bold)\n\t\t\t: type === 'events'\n\t\t\t? composeColors(color.magenta, color.bold)\n\t\t\t: composeColors(color.gray, color.bold)\n\tconst formatApi = (api: string) => pcolor(`${api}`)\n\tconst formatCommand = (command: string) => pcolor(`/${command}`)\n\tconst formatContext = (context: string) => pcolor(`${context} (${context})`)\n\tconst formatEvent = (event: string) => pcolor(`${event} (${manifest.events[event].length})`)\n\tconst formatMiddleware = (middleware: string) => pcolor(manifest.middleware[parseInt(middleware)]?.__path)\n\tconst formatter =\n\t\ttype === 'api'\n\t\t\t? formatApi\n\t\t\t: type === 'commands'\n\t\t\t? formatCommand\n\t\t\t: type === 'context'\n\t\t\t? formatContext\n\t\t\t: type === 'events'\n\t\t\t? formatEvent\n\t\t\t: formatMiddleware\n\tconst handlers = Object.keys(manifest[type]).map(formatter)\n\tlogger.debug(`Loading ${type}: ${handlers.join(', ')}`)\n\n\tconst scanPredicate: ScanPredicate = async (entry: BaseConfig, entryKeys) => {\n\t\t// Skip for nested entries (no __path)\n\t\tif (!entry.__path) {\n\t\t\treturn\n\t\t}\n\n\t\t// Load the module\n\t\tconst basePath = path.join(process.cwd(), entry.__plugin?.path ?? '.')\n\t\tconst importPath = pathToFileURL(path.join(basePath, entry.__path)).toString()\n\n\t\tconst handler: HandlerRecord = {\n\t\t\tauto: entry.__auto,\n\t\t\tdescription: entry.description,\n\t\t\thandler: await import(importPath),\n\t\t\tkey: entryKeys.join('/'),\n\t\t\tmodule: entry.__module,\n\t\t\tpath: entry.__path,\n\t\t\tplugin: entry.__plugin,\n\t\t\ttype: type === 'events' ? 'event' : type === 'commands' ? 'command' : type\n\t\t}\n\n\t\t// Assign the handler to the collection, handling difference between types\n\t\tif (type === 'events') {\n\t\t\tconst eventKey = entryKeys[0]\n\t\t\tif (!collection.has(eventKey)) {\n\t\t\t\tcollection.set(eventKey, [] as T)\n\t\t\t}\n\t\t\tconst handlers = collection.get(eventKey) as HandlerRecord[]\n\t\t\thandlers.push(handler)\n\t\t} else if (type === 'commands') {\n\t\t\tconst commandKey = entryKeys.join(' ')\n\t\t\tcollection.set(commandKey, handler as T)\n\t\t} else if (type === 'context') {\n\t\t\tconst contextKey = entryKeys[0]\n\t\t\tcollection.set(contextKey, handler as T)\n\t\t} else if (type === 'middleware') {\n\t\t\tcollection.set(entryKeys[0], handler as T)\n\t\t} else if (type === 'api') {\n\t\t\tcollection.set(entryKeys.join('/'), handler as T)\n\t\t}\n\t}\n\n\t// Scan context a bit differently due to nesting\n\tif (type === 'context') {\n\t\tawait scanEntries(scanPredicate, { manifestEntries: manifest.context.message, type })\n\t\tawait scanEntries(scanPredicate, { manifestEntries: manifest.context.user, type })\n\t} else {\n\t\tawait scanEntries(scanPredicate, { manifestEntries: manifest[type], type })\n\t}\n\n\treturn collection\n}\n"]}