import fs from 'node:fs/promises';
import { DEFAULT_CONFIG } from '../../core/constants.js';
import { getConfig } from '../../core/config.js';
import { createRequire } from 'node:module';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import { logger } from '../../core/logger.js';
import path from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';

const __DIRNAME = path.dirname(fileURLToPath(import.meta.url));
const execAsync = promisify(exec);
const require2 = createRequire(import.meta.url);
const packageJson = require2("../../../package.json");
async function filterExistingPaths(paths, basePath = process.cwd()) {
  const result = [];
  for (const relativePath of paths) {
    const absolutePath = path.resolve(basePath, relativePath);
    try {
      await fs.stat(absolutePath);
      result.push(relativePath);
    } catch (err) {
    }
  }
  return result;
}
async function findNodeModules(basePath) {
  const nodeModulesPath = path.join(basePath, "node_modules");
  try {
    await fs.access(nodeModulesPath);
    return nodeModulesPath;
  } catch (error) {
    const parentPath = path.resolve(basePath, "..");
    if (parentPath !== basePath) {
      return findNodeModules(parentPath);
    } else {
      return null;
    }
  }
}
async function findPackagePath(packageName, currentPath) {
  const nodeModulesPath = await findNodeModules(currentPath);
  if (!nodeModulesPath) {
    logger.debug(`Could not find node_modules folder for ${packageName}`);
    return null;
  }
  const pnpmNodeModulesPath = path.resolve(nodeModulesPath, ".pnpm");
  const isPnpm = await fs.access(pnpmNodeModulesPath).then(
    () => true,
    () => false
  );
  let packagePath = null;
  if (isPnpm) {
    logger.debug(`Found pnpm node_modules folder for ${packageName}`);
    try {
      const { stdout } = await execAsync(`pnpm list ${packageName} --json`, { cwd: currentPath });
      const packages = JSON.parse(stdout);
      const packageInfo = Array.isArray(packages) ? packages[0] : packages;
      packagePath = packageInfo.dependencies[packageName].path;
    } catch (error) {
      logger.error("", error);
    }
  } else {
    const candidatePath = path.join(nodeModulesPath, packageName);
    logger.debug(`Checking for ${packageName} in ${candidatePath}`);
    try {
      await fs.access(candidatePath);
      packagePath = candidatePath;
    } catch (error) {
    }
  }
  if (packagePath) {
    return path.relative(process.cwd(), packagePath);
  }
  const parentPath = path.resolve(nodeModulesPath, "..");
  return parentPath !== currentPath ? findPackagePath(packageName, parentPath) : null;
}
function getSage(commandConfig, config) {
  if (!config) {
    config = getConfig();
  }
  if (commandConfig?.sage === false || commandConfig?.sage === void 0 && config?.sage === false) {
    return {
      defer: false,
      deferBuffer: 0,
      ephemeral: false,
      errorReplies: false
    };
  }
  return {
    ...DEFAULT_CONFIG.sage,
    ...config?.sage === false ? {} : commandConfig?.sage ?? config?.sage ?? {}
  };
}
async function getWatchedPlugins(config) {
  const pluginNames = config.plugins?.map((plugin) => typeof plugin === "string" ? plugin : plugin[0]) ?? [];
  const watchedPlugins = {};
  for (const name of pluginNames) {
    try {
      const packagePath = await findPackagePath(name, process.cwd());
      const watchFilePath = path.join(packagePath, ".robo", "watch.mjs");
      const importPath = pathToFileURL(path.join(process.cwd(), watchFilePath)).toString();
      await import(importPath);
      watchedPlugins[watchFilePath] = { importPath, name };
    } catch (error) {
    }
  }
  return watchedPlugins;
}
function hasProperties(obj, props) {
  return typeof obj === "object" && obj !== null && props.every((prop) => prop in obj);
}
async function locateInHierarchy(targetPath, currentDir = process.cwd()) {
  const currentPath = path.join(currentDir, targetPath);
  try {
    await fs.access(currentPath);
    return currentPath;
  } catch {
    const upperDir = path.dirname(currentDir);
    if (upperDir === currentDir) {
      return void 0;
    }
    return locateInHierarchy(targetPath, upperDir);
  }
}
function replaceSrcWithBuildInRecord(record, basePath = process.cwd()) {
  const result = {};
  for (const [key, values] of Object.entries(record)) {
    result[key] = values.map((value) => {
      const relativePath = path.relative(basePath, value);
      if (relativePath.startsWith("src/")) {
        return relativePath.replace("src/", "../.robo/build/");
      }
      return "../" + relativePath;
    });
  }
  return result;
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const IS_WINDOWS = /^win/.test(process.platform);
function cmd(packageManager) {
  return IS_WINDOWS ? `${packageManager}.cmd` : packageManager;
}
function getPkgManager() {
  const userAgent = process.env.npm_config_user_agent;
  if (userAgent?.startsWith("yarn")) {
    return "yarn";
  } else if (userAgent?.startsWith("pnpm")) {
    return "pnpm";
  } else {
    return "npm";
  }
}
function timeout(callback, ms) {
  return new Promise(
    (resolve) => setTimeout(() => {
      resolve(callback());
    }, ms)
  );
}
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
  const queue = [];
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.length > 0) {
      const { task, args, resolve } = queue.shift();
      run(task, resolve, args);
    }
  };
  const run = async (fn, resolve, args) => {
    activeCount++;
    const result = fn(...args);
    resolve(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (fn, resolve, args) => {
    queue.push({ task: fn, args, resolve });
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency && queue.length > 0) {
        const { task, args: args2, resolve: resolve2 } = queue.shift();
        run(task, resolve2, args2);
      }
    })();
  };
  const generator = (fn, ...args) => new Promise((resolve) => {
    enqueue(fn, resolve, args);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.length
    },
    clearQueue: {
      value: () => {
        queue.length = 0;
      }
    }
  });
  return generator;
}

export { IS_WINDOWS, __DIRNAME, cmd, pLimit as default, filterExistingPaths, findNodeModules, findPackagePath, getPkgManager, getSage, getWatchedPlugins, hasProperties, locateInHierarchy, packageJson, replaceSrcWithBuildInRecord, sleep, timeout };
