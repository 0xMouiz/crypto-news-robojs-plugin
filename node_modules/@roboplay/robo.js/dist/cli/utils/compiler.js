import fs from 'fs/promises';
import path from 'path';
import { replaceSrcWithBuildInRecord, hasProperties } from './utils.js';
import { logger } from '../../core/logger.js';
import { env } from '../../core/env.js';

const srcDir = path.join(process.cwd(), "src");
const distDir = path.join(process.cwd(), ".robo", "build");
let ts;
let transform;
try {
  const [typescript, swc] = await Promise.all([import('typescript'), import('@swc/core')]);
  ts = typescript.default;
  transform = swc.transform;
} catch {
}
async function traverse(dir, options, compilerOptions, transform2) {
  const { parallel = 20 } = options;
  const isIncremental = options.files?.length > 0;
  let files;
  try {
    if (isIncremental) {
      files = options.files.map((file) => path.join(process.cwd(), file));
      logger.debug(`Incrementally compiling:`, files);
    } else {
      files = await fs.readdir(dir);
    }
  } catch (e) {
    if (hasProperties(e, ["code"]) && e.code === "ENOENT") {
      logger.debug(`Directory ${dir} does not exist, skipping traversal.`);
      return;
    } else {
      throw e;
    }
  }
  const tasks = [];
  for (const file of files) {
    const filePath = isIncremental ? file : path.join(dir, file);
    const stat = await fs.stat(filePath);
    if (stat.isDirectory() && !isIncremental) {
      tasks.push(traverse(filePath, options, compilerOptions, transform2));
    } else if (/\.(js|ts|tsx)$/.test(file)) {
      tasks.push(
        (async () => {
          const fileContents = await fs.readFile(filePath, "utf-8");
          const transformed = await transform2(fileContents, {
            filename: filePath,
            sourceMaps: env.nodeEnv === "production" ? false : "inline",
            jsc: {
              target: "esnext",
              baseUrl: options.baseUrl,
              paths: options.paths,
              parser: {
                syntax: "typescript",
                tsx: filePath.endsWith(".tsx"),
                dynamicImport: true,
                decorators: true
              },
              transform: {
                legacyDecorator: true
              }
            }
          });
          const distPath = path.join(distDir, path.relative(srcDir, filePath.replace(/\.(js|ts|tsx)$/, ".js")));
          await fs.mkdir(path.dirname(distPath), { recursive: true });
          await fs.writeFile(distPath, transformed.code);
        })()
      );
    }
    if (tasks.length >= parallel) {
      await Promise.all(tasks);
      tasks.length = 0;
    }
  }
  await Promise.all(tasks);
}
async function compile(options) {
  const startTime = Date.now();
  if (typeof ts === "undefined" || typeof transform === "undefined") {
    await fs.rm(distDir, { recursive: true, force: true });
    logger.debug("Copying srcDir to distDir without transversing...");
    await copyDir(srcDir, distDir);
    return Date.now() - startTime;
  }
  const configFileName = path.join(process.cwd(), "tsconfig.json");
  try {
    await fs.access(configFileName);
  } catch (error2) {
    await fs.rm(distDir, { recursive: true, force: true });
    logger.debug("Copying srcDir to distDir without transversing...");
    await copyDir(srcDir, distDir);
    return Date.now() - startTime;
  }
  if (typeof ts === "undefined" || typeof transform === "undefined") {
    await fs.rm(distDir, { recursive: true, force: true });
    logger.debug("Copying srcDir to distDir without transversing...");
    await copyDir(srcDir, distDir);
    return Date.now() - startTime;
  }
  const configFileContents = await fs.readFile(configFileName, "utf8");
  const { config: tsconfig, error } = ts.parseConfigFileTextToJson(configFileName, configFileContents);
  if (error) {
    logger.error("Error parsing tsconfig.json:", error);
    process.exit(1);
  }
  const { options: tsOptions } = ts.convertCompilerOptionsFromJson(
    tsconfig.compilerOptions,
    path.dirname(configFileName)
  );
  if (tsOptions.errors) {
    logger.error("Error parsing compiler options from tsconfig.json");
    process.exit(1);
  }
  if (!options?.files?.length) {
    logger.debug(`Cleaning ${distDir}...`);
    await fs.rm(distDir, { recursive: true, force: true });
  }
  logger.debug(`Compiling ${srcDir} to ${distDir}...`);
  const baseUrl = tsOptions.baseUrl ?? process.cwd();
  const compileOptions = {
    baseUrl,
    paths: replaceSrcWithBuildInRecord(tsOptions.paths ?? {}),
    ...options ?? {}
  };
  logger.debug(`Compiler options:`, compileOptions);
  await traverse(srcDir, compileOptions, tsOptions, transform);
  await fs.rm(path.join(process.cwd(), ".swc"), { recursive: true, force: true });
  logger.debug(`Copying additional non-TypeScript files from ${srcDir} to ${distDir}...`);
  await copyDir(srcDir, distDir, [".ts", ".tsx"]);
  return Date.now() - startTime;
}
async function copyDir(src, dest, excludeExtensions = []) {
  await fs.mkdir(dest, { recursive: true });
  const entries = await fs.readdir(src);
  for (const entry of entries) {
    const srcPath = path.join(src, entry);
    const destPath = path.join(dest, entry);
    const entryStat = await fs.stat(srcPath);
    const entryExt = path.extname(srcPath);
    if (excludeExtensions.includes(entryExt)) {
      continue;
    } else if (entryStat.isDirectory()) {
      await copyDir(srcPath, destPath, excludeExtensions);
    } else {
      await fs.copyFile(srcPath, destPath);
    }
  }
}

export { compile };
