import { Command } from 'commander';
import { run } from '../utils/run.js';
import { spawn } from 'child_process';
import { logger } from '../../core/logger.js';
import { FLASHCORE_KEYS, DEFAULT_CONFIG } from '../../core/constants.js';
import { loadConfig, loadConfigPath } from '../../core/config.js';
import { filterExistingPaths, getWatchedPlugins, timeout, getPkgManager, IS_WINDOWS, cmd } from '../utils/utils.js';
import path from 'node:path';
import url from 'node:url';
import { getStateSave } from '../../core/state.js';
import Watcher from '../utils/watcher.js';
import { loadManifest } from '../utils/manifest.js';
import { color, composeColors } from '../../core/color.js';
import { Spirits } from '../utils/spirits.js';
import { buildAction } from './build/index.js';
import { prepareFlashcore, Flashcore } from '../../core/flashcore.js';

const command = new Command("dev").description("Ready, set, code your bot to life! Starts development mode.").option("-s --silent", "do not print anything").option("-v --verbose", "print more information for debugging").action(devAction);
var dev_default = command;
const buildCommand = "robo build --dev";
let spirits;
async function devAction(options) {
  logger({
    enabled: !options.silent,
    level: options.verbose ? "debug" : "info"
  }).info("Starting Robo in development mode...");
  logger.warn(`Thank you for trying Robo.js! This is a pre-release version, so please let us know of issues on GitHub.`);
  logger.debug(`Current working directory:`, process.cwd());
  const config = await loadConfig();
  const configPath = await loadConfigPath();
  let configRelative;
  if (configPath) {
    configRelative = path.relative(process.cwd(), url.fileURLToPath(configPath));
  } else {
    logger.warn(`Could not find configuration file. Using default configuration.`);
  }
  const experimentalKeys = Object.entries(config.experimental ?? {}).filter(([, value]) => value).map(([key]) => key);
  if (experimentalKeys.length > 0) {
    const features = experimentalKeys.map((key) => color.bold(key)).join(", ");
    logger.warn(`Experimental flags enabled: ${features}.`);
  }
  if (config.experimental?.spirits) {
    spirits = new Spirits();
    let isStopping = false;
    const callback = async () => {
      if (isStopping) {
        return;
      }
      isStopping = true;
      await spirits.stopAll();
      process.exit(0);
    };
    process.on("SIGINT", callback);
    process.on("SIGTERM", callback);
  }
  let buildSuccess = false;
  try {
    const start = Date.now();
    await buildAction([], {
      dev: true,
      verbose: options.verbose
    });
    logger.debug(`Build completed in ${Date.now() - start}ms`);
    buildSuccess = true;
  } catch (error) {
    logger.error(error);
  }
  let botProcess;
  let roboSpirit;
  const registerProcessEvents = () => {
    botProcess?.on("message", async (message) => {
      if (message.type === "restart") {
        logger.wait(`Restarting Robo...`);
        botProcess = await rebuildAndRestartBot(botProcess, config, options.verbose, []);
        registerProcessEvents();
      }
    });
  };
  const restartCallback = async (message) => {
    if (message.event === "restart" && message.payload === "trigger") {
      logger.wait(`Restarting Robo...`);
      spirits.off(roboSpirit, restartCallback);
      roboSpirit = await rebuildRobo(roboSpirit, config, options.verbose, []);
      spirits.on(roboSpirit, restartCallback);
    }
  };
  const stateStart = Date.now();
  await prepareFlashcore();
  const persistedState = await Flashcore.get(FLASHCORE_KEYS.state) ?? {};
  logger.debug(`State loaded in ${Date.now() - stateStart}ms`);
  if (buildSuccess && config.experimental?.spirits) {
    roboSpirit = await spirits.newTask({
      event: "start",
      onExit: (exitCode) => {
        if (exitCode !== 0) {
          logger.error(
            composeColors(
              color.bgBlack,
              color.redBright,
              color.underline,
              color.bold
            )(`Robo exited with code ${exitCode}.`),
            `Restarting...`
          );
          return true;
        }
      },
      onRetry: (value) => {
        roboSpirit = value;
        spirits.on(roboSpirit, restartCallback);
        spirits.send(roboSpirit, { event: "set-state", state: persistedState });
      }
    });
    spirits.on(roboSpirit, restartCallback);
    spirits.send(roboSpirit, { event: "set-state", state: persistedState });
  } else if (buildSuccess) {
    botProcess = await run();
    registerProcessEvents();
    botProcess.send({ type: "state-load", state: persistedState });
  } else {
    logger.wait(`Build failed! Waiting for changes before retrying...`);
  }
  let manifest = await loadManifest();
  const watchedPaths = ["src"];
  const additionalFiles = await filterExistingPaths([".env", "tsconfig.json", configRelative]);
  watchedPaths.push(...additionalFiles);
  const watchedPlugins = await getWatchedPlugins(config);
  Object.keys(watchedPlugins).forEach((pluginPath) => watchedPaths.push(pluginPath));
  logger.debug(`Watching:`, watchedPaths);
  const watcher = new Watcher(watchedPaths, {
    exclude: ["node_modules", ".git"]
  });
  let isUpdating = false;
  watcher.start(async (changes) => {
    logger.debug(`Watcher events: ${changes.map((change) => change.changeType).join(", ")}`);
    if (isUpdating) {
      return logger.debug(`Already updating, skipping...`);
    }
    isUpdating = true;
    try {
      const configChange = changes.find((change) => change.filePath === configRelative);
      const pluginChange = changes.find((change) => Object.keys(watchedPlugins).includes(change.filePath));
      if (configChange) {
        const fileName = configChange.filePath.split("/").pop();
        logger.wait(`${color.bold(fileName)} file was updated. Restarting to apply configuration...`);
      } else if (pluginChange) {
        const plugin = watchedPlugins[pluginChange.filePath];
        logger.wait(`${color.bold(plugin.name)} plugin was updated. Restarting to apply changes...`);
      } else {
        logger.wait(`Change detected. Restarting Robo...`);
      }
      if (config.experimental?.spirits) {
        roboSpirit = await rebuildRobo(roboSpirit, config, options.verbose, changes);
        spirits.on(roboSpirit, restartCallback);
      } else {
        botProcess = await rebuildAndRestartBot(botProcess, config, options.verbose, changes);
        registerProcessEvents();
      }
      const newManifest = await loadManifest();
      const oldPermissions = manifest.permissions ?? [];
      const newPermissions = newManifest.permissions ?? [];
      manifest = newManifest;
      if (JSON.stringify(oldPermissions) !== JSON.stringify(newPermissions)) {
        logger.warn(
          `Permissions have changed! Run ${color.bold("robo invite")} to update your Robo's guild permissions.`
        );
      }
    } finally {
      isUpdating = false;
    }
  });
}
async function buildAsync(command2, config, verbose, changes) {
  return new Promise((resolve, reject) => {
    const args = command2.split(" ");
    const start = Date.now();
    if (config.experimental?.spirits) {
      spirits.newTask({
        event: "build",
        payload: {
          files: changes.map((change) => change.filePath)
        },
        verbose
      }).then(() => {
        logger.debug(`Build completed in ${Date.now() - start}ms`);
        resolve(true);
      }).catch(() => resolve(false));
    } else {
      let pkgManager = getPkgManager();
      if (pkgManager === "pnpm" && IS_WINDOWS) {
        logger.debug(
          `Detected Windows. Using ${color.bold(cmd("npm"))} instead of ${color.bold(cmd("pnpm"))} to build.`
        );
        pkgManager = "npm";
      }
      if (pkgManager === "npm" || pkgManager === "pnpm") {
        args.splice(0, 0, "exec");
      }
      if (pkgManager === "npm") {
        const optionsIndex = args.findIndex((arg) => arg.startsWith("-"));
        if (optionsIndex !== -1) {
          args.splice(optionsIndex, 0, "--");
        }
      }
      logger.debug(`> ${cmd(pkgManager)} ${args.join(" ")}`);
      const childProcess = spawn(cmd(pkgManager), args, {
        env: { ...process.env, FORCE_COLOR: "1" },
        stdio: "inherit"
      });
      childProcess.on("close", (code) => {
        if (code === 0) {
          logger.debug(`Build completed in ${Date.now() - start}ms`);
          resolve(true);
        } else {
          resolve(false);
        }
      });
      childProcess.on("error", (error) => {
        reject(error);
        resolve(false);
      });
    }
  });
}
async function rebuildRobo(spiritId, config, verbose, changes) {
  const roboSpirit = spiritId;
  const isValid = roboSpirit !== null && roboSpirit !== void 0;
  const stateSaveStart = Date.now();
  logger.debug("Saving state...");
  const savedState = await spirits.exec(roboSpirit, {
    event: "get-state"
  }) ?? {};
  logger.debug(`Saved state in ${Date.now() - stateSaveStart}ms:`, savedState);
  let isTerminated = false;
  const terminate = new Promise((resolve) => {
    if (!isValid) {
      return resolve();
    }
    const spirit = spirits.get(roboSpirit);
    const callback = () => {
      logger.debug(`Gracefully stopped Robo spirit (${composeColors(color.bold, color.cyan)(roboSpirit)})`);
      spirit.worker.off("exit", callback);
      spirit.isTerminated = true;
      isTerminated = true;
      resolve();
    };
    spirit.worker.once("exit", callback);
    spirit.worker.on("message", (message) => {
      if (message.payload === "exit") {
        callback();
      }
    });
    spirits.send(roboSpirit, { event: "restart", verbose });
  });
  const forceAbort = timeout(() => {
    if (!isTerminated && isValid) {
      logger.warn("Robo termination timed out. Force stopping...");
      spirits.stop(roboSpirit, true);
    }
  }, config?.timeouts?.lifecycle ?? DEFAULT_CONFIG.timeouts.lifecycle);
  const awaitStop = Promise.race([terminate, forceAbort]);
  const [success] = await Promise.all([
    buildAsync(buildCommand + (verbose ? " --verbose" : ""), config, verbose, changes),
    awaitStop
  ]);
  if (!success) {
    logger.wait(`Build failed! Waiting for changes before retrying...`);
    return null;
  }
  const start = Date.now();
  const newSpiritId = await spirits.newTask({ event: "start" });
  logger.debug(`Robo spirit (${composeColors(color.bold, color.cyan)(newSpiritId)}) started in ${Date.now() - start}ms`);
  spirits.send(newSpiritId, { event: "set-state", state: savedState });
  return newSpiritId;
}
async function rebuildAndRestartBot(bot, config, verbose, changes) {
  const currentBot = bot;
  let isTerminated = false;
  const terminate = new Promise((resolve) => {
    if (!currentBot) {
      return resolve();
    }
    currentBot?.on("exit", () => {
      logger.debug("Terminated previous bot process");
      isTerminated = true;
      resolve();
    });
  });
  const forceAbort = timeout(() => {
    if (!isTerminated && currentBot) {
      logger.warn("Robo termination timed out. Force stopping...");
    }
    currentBot?.kill("SIGKILL");
  }, config?.timeouts?.lifecycle ?? DEFAULT_CONFIG.timeouts.lifecycle);
  logger.debug("Saving state...");
  const savedState = await getStateSave(currentBot);
  logger.debug("Sending restart signal...");
  currentBot?.send({ type: "restart" });
  const awaitStop = Promise.race([terminate, forceAbort]);
  const [success] = await Promise.all([
    buildAsync(buildCommand + (verbose ? " --verbose" : ""), config, verbose, changes),
    awaitStop
  ]);
  if (!success) {
    logger.wait(`Build failed! Waiting for changes before retrying...`);
    return null;
  }
  const newBot = await run();
  newBot.send({ type: "state-load", state: savedState });
  return newBot;
}

export { buildAsync, dev_default as default };
